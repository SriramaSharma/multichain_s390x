From 544ccd6bd17bfd0e98b3109e43c6600d92c19eea Mon Sep 17 00:00:00 2001
From: Krishna Harsha Voora <krishvoor@in.ibm.com>
Date: Mon, 1 Apr 2019 02:34:58 -0400
Subject: [PATCH] Applying BE Changes to Bitcoin & Multichain for s390x arch.

    1) Changes specific to s390x added to v8_data_lib.py
    2) Changes specific to s390x added for 2.0-dev
    3) Updated wallet/dbflat.cpp & wallet/dbflat.h  accordingly to work on s390x.

Signed-off-by: Krishna Harsha Voora <krishvoor@in.ibm.com>
---
 configure.ac                      |  13 ++-
 depends/v8_data_lib.py            |  12 ++-
 src/Makefile.am                   |   4 +-
 src/chain/txmempool.cpp           |   4 +-
 src/chainparams/params.cpp        |  40 ++++----
 src/compat/byteswap.h             |  47 +++++++++
 src/compat/endian.h               | 194 ++++++++++++++++++++++++++++++++++++
 src/core/main.cpp                 |   3 +-
 src/crypto/common.h               |  78 +++------------
 src/entities/asset.cpp            |  13 ++-
 src/miner/miner.cpp               |  21 ++--
 src/net/net.cpp                   |   3 +-
 src/net/netbase.h                 |   2 +-
 src/primitives/block.cpp          |   2 +-
 src/primitives/block.h            |   9 ++
 src/primitives/transaction.h      |   5 +-
 src/protocol/multichainscript.cpp |  26 ++---
 src/protocol/multichaintx.cpp     |   4 +-
 src/protocol/relay.cpp            |   2 +-
 src/rpc/rpcassets.cpp             |  21 ++--
 src/rpc/rpcdebug.cpp              |   2 +-
 src/rpc/rpcutils.cpp              |   4 +-
 src/script/script.h               |  17 ++--
 src/structs/hash.cpp              |   6 +-
 src/utils/declare.h               |   3 +-
 src/utils/serialize.h             | 201 ++++++++++++++++++++++++--------------
 src/utils/tools.cpp               |   8 +-
 src/utils/utility.cpp             |  28 +++++-
 src/utils/utilparse.cpp           |  12 +--
 src/v8/v8engine.cpp               |  10 +-
 src/wallet/dbflat.cpp             |  49 +++++++---
 src/wallet/dbflat.h               |   2 +
 src/wallet/wallet.cpp             |   6 +-
 src/wallet/walletcoins.cpp        |  32 +++---
 34 files changed, 611 insertions(+), 272 deletions(-)
 create mode 100644 src/compat/byteswap.h
 create mode 100644 src/compat/endian.h

diff --git a/configure.ac b/configure.ac
index 9f5ebec..5f42a00 100644
--- a/configure.ac
+++ b/configure.ac
@@ -363,8 +363,8 @@ if test x$use_lcov = xyes; then
     [AC_MSG_ERROR("lcov testing requested but --coverage flag does not work")])
 fi
 
-dnl Require little endian
-AC_C_BIGENDIAN([AC_MSG_ERROR("Big Endian not supported")])
+dnl Check for endianness
+AC_C_BIGENDIAN
 
 dnl Check for pthread compile/link requirements
 AX_PTHREAD
@@ -451,17 +451,22 @@ if test x$TARGET_OS = xdarwin; then
   AX_CHECK_LINK_FLAG([[-Wl,-dead_strip]], [LDFLAGS="$LDFLAGS -Wl,-dead_strip"])
 fi
 
-AC_CHECK_HEADERS([endian.h stdio.h stdlib.h unistd.h strings.h sys/types.h sys/stat.h sys/select.h sys/prctl.h])
+AC_CHECK_HEADERS([endian.h byteswap.h stdio.h stdlib.h unistd.h strings.h sys/types.h sys/stat.h sys/select.h sys/prctl.h])
 AC_SEARCH_LIBS([getaddrinfo_a], [anl], [AC_DEFINE(HAVE_GETADDRINFO_A, 1, [Define this symbol if you have getaddrinfo_a])])
 AC_SEARCH_LIBS([inet_pton], [nsl resolv], [AC_DEFINE(HAVE_INET_PTON, 1, [Define this symbol if you have inet_pton])])
 
 AC_CHECK_DECLS([strnlen])
 
-AC_CHECK_DECLS([le32toh, le64toh, htole32, htole64, be32toh, be64toh, htobe32, htobe64],,,
+AC_CHECK_DECLS([le16toh, le32toh, le64toh, htole16, htole32, htole64, be16toh, be32toh, be64toh, htobe16, htobe32, htobe64],,,
 		[#if HAVE_ENDIAN_H
                  #include <endian.h>
                  #endif])
 
+AC_CHECK_DECLS([bswap_16, bswap_32, bswap_64],,,
+		[#if HAVE_BYTESWAP_H
+                 #include <byteswap.h>
+                 #endif])
+
 dnl Check for MSG_NOSIGNAL
 AC_MSG_CHECKING(for MSG_NOSIGNAL)
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/socket.h>]],
diff --git a/depends/v8_data_lib.py b/depends/v8_data_lib.py
index 5a28451..60ebbcf 100644
--- a/depends/v8_data_lib.py
+++ b/depends/v8_data_lib.py
@@ -1,6 +1,7 @@
 import logging
 import os
 import sys
+import platform
 from argparse import ArgumentParser
 from itertools import chain
 from subprocess import call
@@ -19,6 +20,15 @@ global {PREFIX}_end;
 {PREFIX}_size:  dd {PREFIX}_end-{PREFIX}_start
 """
 
+ARCH=platform.processor()
+
+if ARCH ==  "s390x":
+	release_arch = "s390x"
+elif ARCH == "x86_64":
+	release_arch = "x64"
+else:
+	print ("Unknown Architecture")
+
 
 def get_bin_type(platform):
     if platform == "darwin":
@@ -90,7 +100,7 @@ def get_options():
 def main():
     logging.basicConfig(stream=sys.stdout, level=logging.INFO, format="%(asctime)s %(levelname)-7s %(message)s")
     options = get_options()
-    os.chdir(str(Path(options.multichain) / "v8build" / "v8" / "out.gn" / "x64.release"))
+    os.chdir(str(Path(options.multichain) / "v8build" / "v8" / "out" / "s390x.release"))
     process_bin_files(options.platform)
     return 0
 
diff --git a/src/Makefile.am b/src/Makefile.am
index 38a6b74..4740602 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -161,7 +161,9 @@ BITCOIN_CORE_H = \
   wallet/wallettxs.h \
   wallet/wallet_ismine.h \
   wallet/walletdb.h \
-  compat/sanity.h
+  compat/sanity.h \
+  compat/byteswap.h \
+  compat/endian.h
 
 JSON_H = \
   json/json_spirit.h \
diff --git a/src/chain/txmempool.cpp b/src/chain/txmempool.cpp
index 3b303c0..96c801c 100644
--- a/src/chain/txmempool.cpp
+++ b/src/chain/txmempool.cpp
@@ -381,7 +381,7 @@ public:
     void Write(CAutoFile& fileout) const
     {
         fileout << nBestSeenHeight;
-        fileout << history.size();
+        fileout << (uint32_t)history.size();
         BOOST_FOREACH(const CBlockAverage& entry, history)
         {
             entry.Write(fileout);
@@ -392,7 +392,7 @@ public:
     {
         int nFileBestSeenHeight;
         filein >> nFileBestSeenHeight;
-        size_t numEntries;
+        uint32_t numEntries;
         filein >> numEntries;
         if (numEntries <= 0 || numEntries > 10000)
             throw runtime_error("Corrupt estimates file. Must have between 1 and 10k entries.");
diff --git a/src/chainparams/params.cpp b/src/chainparams/params.cpp
index f162ab4..e4ff538 100644
--- a/src/chainparams/params.cpp
+++ b/src/chainparams/params.cpp
@@ -342,7 +342,7 @@ int mc_MultichainParams::SetParam(const char *param,const char* value,int size)
         memcpy(m_lpData+offset+MC_PRM_PARAM_SIZE_BYTES,value,size);
     }
     
-    mc_PutLE(m_lpData+offset,&size,MC_PRM_PARAM_SIZE_BYTES);
+    mc_PutLE(m_lpData+offset,size,MC_PRM_PARAM_SIZE_BYTES);
     offset+=MC_PRM_PARAM_SIZE_BYTES;
     m_lpCoord[2 * index + 0]=offset;
     m_lpCoord[2 * index + 1]=size;
@@ -384,7 +384,7 @@ int mc_MultichainParams::SetParam(const char *param,int64_t value)
             return MC_ERR_INTERNAL_ERROR;
     }
 
-    mc_PutLE(buf,&value,size);
+    mc_PutLE(buf,value,size);
     return SetParam(param,buf,size);
 }
 
@@ -511,17 +511,17 @@ int mc_MultichainParams::Create(const char* name,int version)
                             case MC_PRM_INT32:
                             case MC_PRM_UINT32:
                                 size=4;
-                                mc_PutLE(ptrData,&(param->m_DefaultIntegerValue),4);
+                                mc_PutLE(ptrData,(param->m_DefaultIntegerValue),4);
                                 break;
                             case MC_PRM_INT64:
                                 size=8;
-                                mc_PutLE(ptrData,&(param->m_DefaultIntegerValue),8);
+                                mc_PutLE(ptrData,(param->m_DefaultIntegerValue),8);
                                 if(strcmp(param->m_Name,"maxstdelementsize") == 0)
                                 {
                                     if(version<20003)
                                     {
                                         override_int64=8192;
-                                        mc_PutLE(ptrData,&override_int64,8);
+                                        mc_PutLE(ptrData,override_int64,8);
                                     }
                                 }                                   
                                 break;
@@ -538,18 +538,18 @@ int mc_MultichainParams::Create(const char* name,int version)
                             network_port=mc_RandomInRange(0,sizeof(FreePortRangesOver50)/sizeof(uint32_t)-1);
                             network_port=FreePortRangesOver50[network_port];
                             network_port+=1+2*mc_RandomInRange(0,24);
-                            mc_PutLE(ptrData,&network_port,4);
+                            mc_PutLE(ptrData,network_port,4);
                         }
                         if(strcmp(param->m_Name,"defaultrpcport") == 0)
                         {
                             size=4;
                             rpc_port=network_port-1;
-                            mc_PutLE(ptrData,&rpc_port,4);
+                            mc_PutLE(ptrData,rpc_port,4);
                         }
                         if(strcmp(param->m_Name,"protocolversion") == 0)
                         {
                             size=4;
-                            mc_PutLE(ptrData,&version,4);
+                            mc_PutLE(ptrData,version,4);
                         }
                         if(strcmp(param->m_Name,"chainname") == 0)
                         {
@@ -608,7 +608,7 @@ int mc_MultichainParams::Create(const char* name,int version)
                         break;
                 }
 
-                mc_PutLE(m_lpData+offset,&size,MC_PRM_PARAM_SIZE_BYTES);
+                mc_PutLE(m_lpData+offset,size,MC_PRM_PARAM_SIZE_BYTES);
                 offset+=MC_PRM_PARAM_SIZE_BYTES;
                 m_lpCoord[2 * i + 0]=offset;
                 m_lpCoord[2 * i + 1]=size;
@@ -818,7 +818,9 @@ int mc_MultichainParams::Read(const char* name,int argc, char* argv[],int create
                     }
                     else
                     {
-                        *(int32_t*)ptrData=(int32_t)atol(ptr);
+                        // *(int32_t*)ptrData=(int32_t)atol(ptr);
+			int32_t tmp =(int32_t)atol(ptr);
+			mc_PutLE(ptrData, tmp, 4);
                     }
                     break;
                 case MC_PRM_UINT32:
@@ -842,7 +844,9 @@ int mc_MultichainParams::Read(const char* name,int argc, char* argv[],int create
                     }
                     else
                     {
-                        *(int32_t*)ptrData=(int32_t)atol(ptr);
+                       // *(int32_t*)ptrData=(int32_t)atol(ptr);
+                        int32_t tmp =(int32_t)atol(ptr);
+                        mc_PutLE(ptrData, tmp, 4);
                     }
                     if(ptr[0]=='-')
                     {
@@ -873,7 +877,7 @@ int mc_MultichainParams::Read(const char* name,int argc, char* argv[],int create
                     break;
             }            
             
-            mc_PutLE(m_lpData+offset,&size,MC_PRM_PARAM_SIZE_BYTES);
+            mc_PutLE(m_lpData+offset,size,MC_PRM_PARAM_SIZE_BYTES);
             offset+=MC_PRM_PARAM_SIZE_BYTES;
             m_lpCoord[2 * i + 0]=offset;
             m_lpCoord[2 * i + 1]=size;
@@ -901,7 +905,7 @@ int mc_MultichainParams::Read(const char* name,int argc, char* argv[],int create
                 {
                     memcpy(ptrData,ptr,size);
                 }            
-                mc_PutLE(m_lpData+offset,&size,MC_PRM_PARAM_SIZE_BYTES);
+                mc_PutLE(m_lpData+offset,size,MC_PRM_PARAM_SIZE_BYTES);
                 offset+=MC_PRM_PARAM_SIZE_BYTES;
                 m_lpCoord[2 * i + 0]=offset;
                 m_lpCoord[2 * i + 1]=size;
@@ -975,7 +979,7 @@ int mc_MultichainParams::Set(const char *name,const char *source,int source_size
                     {
                         memcpy(ptrData,source+j,size);
                     }
-                    mc_PutLE(m_lpData+offset,&size,MC_PRM_PARAM_SIZE_BYTES);
+                    mc_PutLE(m_lpData+offset,size,MC_PRM_PARAM_SIZE_BYTES);
                     offset+=MC_PRM_PARAM_SIZE_BYTES;
                     m_lpCoord[2 * i + 0]=offset;
                     m_lpCoord[2 * i + 1]=size;
@@ -1040,7 +1044,7 @@ int mc_MultichainParams::Clone(const char* name, mc_MultichainParams* source)
             {
                 memcpy(ptrData,ptr,size);
             }
-            mc_PutLE(m_lpData+offset,&size,MC_PRM_PARAM_SIZE_BYTES);
+            mc_PutLE(m_lpData+offset,size,MC_PRM_PARAM_SIZE_BYTES);
             offset+=MC_PRM_PARAM_SIZE_BYTES;
             m_lpCoord[2 * i + 0]=offset;
             m_lpCoord[2 * i + 1]=size;
@@ -1210,7 +1214,7 @@ int mc_MultichainParams::Validate()
                                         break;
                                     case MC_PRM_INT64:
                                         size=8;
-                                        mc_PutLE(ptrData,&((m_lpParams+i)->m_DefaultIntegerValue),8);
+                                        mc_PutLE(ptrData,((m_lpParams+i)->m_DefaultIntegerValue),8);
                                         break;
                                     case MC_PRM_DOUBLE:
                                         size=8;
@@ -1218,11 +1222,11 @@ int mc_MultichainParams::Validate()
                                         break;
                                     default:
                                         size=4;
-                                        mc_PutLE(ptrData,&((m_lpParams+i)->m_DefaultIntegerValue),4);
+                                        mc_PutLE(ptrData,((m_lpParams+i)->m_DefaultIntegerValue),4);
                                         break;
                                 }
                                 
-                                mc_PutLE(m_lpData+offset,&size,MC_PRM_PARAM_SIZE_BYTES);
+                                mc_PutLE(m_lpData+offset,size,MC_PRM_PARAM_SIZE_BYTES);
                                 offset+=MC_PRM_PARAM_SIZE_BYTES;
                                 m_lpCoord[2 * i + 0]=offset;
                                 m_lpCoord[2 * i + 1]=size;
diff --git a/src/compat/byteswap.h b/src/compat/byteswap.h
new file mode 100644
index 0000000..899220b
--- /dev/null
+++ b/src/compat/byteswap.h
@@ -0,0 +1,47 @@
+// Copyright (c) 2014 The Bitcoin developers
+// Distributed under the MIT software license, see the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#ifndef BITCOIN_COMPAT_BYTESWAP_H
+#define BITCOIN_COMPAT_BYTESWAP_H
+
+#if defined(HAVE_CONFIG_H)
+#include "config/bitcoin-config.h"
+#endif
+
+#include <stdint.h>
+
+#if defined(HAVE_BYTESWAP_H)
+#include <byteswap.h>
+#endif
+
+#if HAVE_DECL_BSWAP_16 == 0
+inline uint16_t bswap_16(uint16_t x)
+{
+    return (x >> 8) | ((x & 0x00ff) << 8);
+}
+#endif // HAVE_DECL_BSWAP16
+
+#if HAVE_DECL_BSWAP_32 == 0
+inline uint32_t bswap_32(uint32_t x)
+{
+    return (((x & 0xff000000U) >> 24) | ((x & 0x00ff0000U) >>  8) |
+            ((x & 0x0000ff00U) <<  8) | ((x & 0x000000ffU) << 24));
+}
+#endif // HAVE_DECL_BSWAP32
+
+#if HAVE_DECL_BSWAP_64 == 0
+inline uint64_t bswap_64(uint64_t x)
+{
+     return (((x & 0xff00000000000000ull) >> 56)
+          | ((x & 0x00ff000000000000ull) >> 40)
+          | ((x & 0x0000ff0000000000ull) >> 24)
+          | ((x & 0x000000ff00000000ull) >> 8)
+          | ((x & 0x00000000ff000000ull) << 8)
+          | ((x & 0x0000000000ff0000ull) << 24)
+          | ((x & 0x000000000000ff00ull) << 40)
+          | ((x & 0x00000000000000ffull) << 56));
+}
+#endif // HAVE_DECL_BSWAP64
+
+#endif // BITCOIN_COMPAT_BYTESWAP_H
diff --git a/src/compat/endian.h b/src/compat/endian.h
new file mode 100644
index 0000000..4d041d6
--- /dev/null
+++ b/src/compat/endian.h
@@ -0,0 +1,194 @@
+// Copyright (c) 2014 The Bitcoin developers
+// Distributed under the MIT software license, see the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#ifndef BITCOIN_COMPAT_ENDIAN_H
+#define BITCOIN_COMPAT_ENDIAN_H
+
+#if defined(HAVE_CONFIG_H)
+#include "config/bitcoin-config.h"
+#endif
+
+#include <stdint.h>
+
+#include "compat/byteswap.h"
+
+#if defined(HAVE_ENDIAN_H)
+#include <endian.h>
+#endif
+
+#if defined(WORDS_BIGENDIAN)
+
+#if HAVE_DECL_HTOBE16 == 0
+inline uint16_t htobe16(uint16_t host_16bits)
+{
+    return host_16bits;
+}
+#endif // HAVE_DECL_HTOBE16
+
+#if HAVE_DECL_HTOLE16 == 0
+inline uint16_t htole16(uint16_t host_16bits)
+{
+    return bswap_16(host_16bits);
+}
+#endif // HAVE_DECL_HTOLE16
+
+#if HAVE_DECL_BE16TOH == 0
+inline uint16_t be16toh(uint16_t big_endian_16bits)
+{
+    return big_endian_16bits;
+}
+#endif // HAVE_DECL_BE16TOH
+
+#if HAVE_DECL_LE16TOH == 0
+inline uint16_t le16toh(uint16_t little_endian_16bits)
+{
+    return bswap_16(little_endian_16bits);
+}
+#endif // HAVE_DECL_LE16TOH
+
+#if HAVE_DECL_HTOBE32 == 0
+inline uint32_t htobe32(uint32_t host_32bits)
+{
+    return host_32bits;
+}
+#endif // HAVE_DECL_HTOBE32
+
+#if HAVE_DECL_HTOLE32 == 0
+inline uint32_t htole32(uint32_t host_32bits)
+{
+    return bswap_32(host_32bits);
+}
+#endif // HAVE_DECL_HTOLE32
+
+#if HAVE_DECL_BE32TOH == 0
+inline uint32_t be32toh(uint32_t big_endian_32bits)
+{
+    return big_endian_32bits;
+}
+#endif // HAVE_DECL_BE32TOH
+
+#if HAVE_DECL_LE32TOH == 0
+inline uint32_t le32toh(uint32_t little_endian_32bits)
+{
+    return bswap_32(little_endian_32bits);
+}
+#endif // HAVE_DECL_LE32TOH
+
+#if HAVE_DECL_HTOBE64 == 0
+inline uint64_t htobe64(uint64_t host_64bits)
+{
+    return host_64bits;
+}
+#endif // HAVE_DECL_HTOBE64
+
+#if HAVE_DECL_HTOLE64 == 0
+inline uint64_t htole64(uint64_t host_64bits)
+{
+    return bswap_64(host_64bits);
+}
+#endif // HAVE_DECL_HTOLE64
+
+#if HAVE_DECL_BE64TOH == 0
+inline uint64_t be64toh(uint64_t big_endian_64bits)
+{
+    return big_endian_64bits;
+}
+#endif // HAVE_DECL_BE64TOH
+
+#if HAVE_DECL_LE64TOH == 0
+inline uint64_t le64toh(uint64_t little_endian_64bits)
+{
+    return bswap_64(little_endian_64bits);
+}
+#endif // HAVE_DECL_LE64TOH
+
+#else // WORDS_BIGENDIAN
+
+#if HAVE_DECL_HTOBE16 == 0
+inline uint16_t htobe16(uint16_t host_16bits)
+{
+    return bswap_16(host_16bits);
+}
+#endif // HAVE_DECL_HTOBE16
+
+#if HAVE_DECL_HTOLE16 == 0
+inline uint16_t htole16(uint16_t host_16bits)
+{
+    return host_16bits;
+}
+#endif // HAVE_DECL_HTOLE16
+
+#if HAVE_DECL_BE16TOH == 0
+inline uint16_t be16toh(uint16_t big_endian_16bits)
+{
+    return bswap_16(big_endian_16bits);
+}
+#endif // HAVE_DECL_BE16TOH
+
+#if HAVE_DECL_LE16TOH == 0
+inline uint16_t le16toh(uint16_t little_endian_16bits)
+{
+    return little_endian_16bits;
+}
+#endif // HAVE_DECL_LE16TOH
+
+#if HAVE_DECL_HTOBE32 == 0
+inline uint32_t htobe32(uint32_t host_32bits)
+{
+    return bswap_32(host_32bits);
+}
+#endif // HAVE_DECL_HTOBE32
+
+#if HAVE_DECL_HTOLE32 == 0
+inline uint32_t htole32(uint32_t host_32bits)
+{
+    return host_32bits;
+}
+#endif // HAVE_DECL_HTOLE32
+
+#if HAVE_DECL_BE32TOH == 0
+inline uint32_t be32toh(uint32_t big_endian_32bits)
+{
+    return bswap_32(big_endian_32bits);
+}
+#endif // HAVE_DECL_BE32TOH
+
+#if HAVE_DECL_LE32TOH == 0
+inline uint32_t le32toh(uint32_t little_endian_32bits)
+{
+    return little_endian_32bits;
+}
+#endif // HAVE_DECL_LE32TOH
+
+#if HAVE_DECL_HTOBE64 == 0
+inline uint64_t htobe64(uint64_t host_64bits)
+{
+    return bswap_64(host_64bits);
+}
+#endif // HAVE_DECL_HTOBE64
+
+#if HAVE_DECL_HTOLE64 == 0
+inline uint64_t htole64(uint64_t host_64bits)
+{
+    return host_64bits;
+}
+#endif // HAVE_DECL_HTOLE64
+
+#if HAVE_DECL_BE64TOH == 0
+inline uint64_t be64toh(uint64_t big_endian_64bits)
+{
+    return bswap_64(big_endian_64bits);
+}
+#endif // HAVE_DECL_BE64TOH
+
+#if HAVE_DECL_LE64TOH == 0
+inline uint64_t le64toh(uint64_t little_endian_64bits)
+{
+    return little_endian_64bits;
+}
+#endif // HAVE_DECL_LE64TOH
+
+#endif // WORDS_BIGENDIAN
+
+#endif // BITCOIN_COMPAT_ENDIAN_H
diff --git a/src/core/main.cpp b/src/core/main.cpp
index cde8c33..79ce454 100644
--- a/src/core/main.cpp
+++ b/src/core/main.cpp
@@ -6944,8 +6944,7 @@ bool ProcessMessages(CNode* pfrom)
         // Checksum
         CDataStream& vRecv = msg.vRecv;
         uint256 hash = Hash(vRecv.begin(), vRecv.begin() + nMessageSize);
-        unsigned int nChecksum = 0;
-        memcpy(&nChecksum, &hash, sizeof(nChecksum));
+        unsigned int nChecksum = ReadLE32((unsigned char*)&hash);
         if (nChecksum != hdr.nChecksum)
         {
             LogPrintf("ProcessMessages(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\n",
diff --git a/src/crypto/common.h b/src/crypto/common.h
index 67c3002..580c72f 100644
--- a/src/crypto/common.h
+++ b/src/crypto/common.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2014 The Bitcoin developers
+// Copyright (c) 2014 The Bitcoin Core developers
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
@@ -11,110 +11,56 @@
 
 #include <stdint.h>
 
-#if defined(HAVE_ENDIAN_H)
-#include <endian.h>
-#endif
+#include "compat/endian.h"
+
+uint16_t static inline ReadLE16(const unsigned char* ptr)
+{
+    return le16toh(*((uint16_t*)ptr));
+}
 
 uint32_t static inline ReadLE32(const unsigned char* ptr)
 {
-#if HAVE_DECL_LE32TOH == 1
     return le32toh(*((uint32_t*)ptr));
-#elif !defined(WORDS_BIGENDIAN)
-    return *((uint32_t*)ptr);
-#else
-    return ((uint32_t)ptr[3] << 24 | (uint32_t)ptr[2] << 16 | (uint32_t)ptr[1] << 8 | (uint32_t)ptr[0]);
-#endif
 }
 
 uint64_t static inline ReadLE64(const unsigned char* ptr)
 {
-#if HAVE_DECL_LE64TOH == 1
     return le64toh(*((uint64_t*)ptr));
-#elif !defined(WORDS_BIGENDIAN)
-    return *((uint64_t*)ptr);
-#else
-    return ((uint64_t)ptr[7] << 56 | (uint64_t)ptr[6] << 48 | (uint64_t)ptr[5] << 40 | (uint64_t)ptr[4] << 32 |
-            (uint64_t)ptr[3] << 24 | (uint64_t)ptr[2] << 16 | (uint64_t)ptr[1] << 8 | (uint64_t)ptr[0]);
-#endif
+}
+
+void static inline WriteLE16(unsigned char* ptr, uint16_t x)
+{
+    *((uint16_t*)ptr) = htole16(x);
 }
 
 void static inline WriteLE32(unsigned char* ptr, uint32_t x)
 {
-#if HAVE_DECL_HTOLE32 == 1
     *((uint32_t*)ptr) = htole32(x);
-#elif !defined(WORDS_BIGENDIAN)
-    *((uint32_t*)ptr) = x;
-#else
-    ptr[3] = x >> 24;
-    ptr[2] = x >> 16;
-    ptr[1] = x >> 8;
-    ptr[0] = x;
-#endif
 }
 
 void static inline WriteLE64(unsigned char* ptr, uint64_t x)
 {
-#if HAVE_DECL_HTOLE64 == 1
     *((uint64_t*)ptr) = htole64(x);
-#elif !defined(WORDS_BIGENDIAN)
-    *((uint64_t*)ptr) = x;
-#else
-    ptr[7] = x >> 56;
-    ptr[6] = x >> 48;
-    ptr[5] = x >> 40;
-    ptr[4] = x >> 32;
-    ptr[3] = x >> 24;
-    ptr[2] = x >> 16;
-    ptr[1] = x >> 8;
-    ptr[0] = x;
-#endif
 }
 
 uint32_t static inline ReadBE32(const unsigned char* ptr)
 {
-#if HAVE_DECL_BE32TOH == 1
     return be32toh(*((uint32_t*)ptr));
-#else
-    return ((uint32_t)ptr[0] << 24 | (uint32_t)ptr[1] << 16 | (uint32_t)ptr[2] << 8 | (uint32_t)ptr[3]);
-#endif
 }
 
 uint64_t static inline ReadBE64(const unsigned char* ptr)
 {
-#if HAVE_DECL_BE64TOH == 1
     return be64toh(*((uint64_t*)ptr));
-#else
-    return ((uint64_t)ptr[0] << 56 | (uint64_t)ptr[1] << 48 | (uint64_t)ptr[2] << 40 | (uint64_t)ptr[3] << 32 |
-            (uint64_t)ptr[4] << 24 | (uint64_t)ptr[5] << 16 | (uint64_t)ptr[6] << 8 | (uint64_t)ptr[7]);
-#endif
 }
 
 void static inline WriteBE32(unsigned char* ptr, uint32_t x)
 {
-#if HAVE_DECL_HTOBE32 == 1
     *((uint32_t*)ptr) = htobe32(x);
-#else
-    ptr[0] = x >> 24;
-    ptr[1] = x >> 16;
-    ptr[2] = x >> 8;
-    ptr[3] = x;
-#endif
 }
 
 void static inline WriteBE64(unsigned char* ptr, uint64_t x)
 {
-#if HAVE_DECL_HTOBE64 == 1
     *((uint64_t*)ptr) = htobe64(x);
-#else
-    ptr[0] = x >> 56;
-    ptr[1] = x >> 48;
-    ptr[2] = x >> 40;
-    ptr[3] = x >> 32;
-    ptr[4] = x >> 24;
-    ptr[5] = x >> 16;
-    ptr[6] = x >> 8;
-    ptr[7] = x;
-#endif
 }
 
 #endif // BITCOIN_CRYPTO_COMMON_H
diff --git a/src/entities/asset.cpp b/src/entities/asset.cpp
index 895c558..088d043 100644
--- a/src/entities/asset.cpp
+++ b/src/entities/asset.cpp
@@ -589,8 +589,8 @@ void mc_EntityDetails::Set(mc_EntityLedgerRow* row)
     
     if(offset)
     {
-        mc_PutLE(m_Ref,&block,4);
-        mc_PutLE(m_Ref+4,&offset,4);
+        mc_PutLE(m_Ref,block,4);
+        mc_PutLE(m_Ref+4,offset,4);
         for(i=0;i<MC_ENT_REF_PREFIX_SIZE;i++)
         {
             m_Ref[8+i]=*(row->m_Key+MC_ENT_KEY_SIZE-1-i);
@@ -929,6 +929,9 @@ int mc_AssetDB::InsertAsset(const void* txid, int offset, int asset_type, uint64
 
     if(add_param)
     {
+	#if HAVE_DECL_HTOBE64 == 1
+		multiple = bswap_32(multiple);  // convert to LE format
+	#endif
         lpDetails->SetSpecialParamValue(MC_ENT_SPRM_ASSET_MULTIPLE,(unsigned char*)&multiple,sizeof(multiple));
     }
     
@@ -2365,7 +2368,7 @@ uint32_t mc_GetABScriptType(void *ptr)
 
 void mc_SetABScriptType(void *ptr,uint32_t type)
 {
-    mc_PutLE((unsigned char*)ptr+MC_AST_ASSET_SCRIPT_TYPE_OFFSET,&type,MC_AST_ASSET_SCRIPT_TYPE_SIZE);
+    mc_PutLE((unsigned char*)ptr+MC_AST_ASSET_SCRIPT_TYPE_OFFSET,type,MC_AST_ASSET_SCRIPT_TYPE_SIZE);
 }
 
 uint32_t mc_GetABRefType(void *ptr)
@@ -2375,7 +2378,7 @@ uint32_t mc_GetABRefType(void *ptr)
 
 void mc_SetABRefType(void *ptr,uint32_t type)
 {
-    mc_PutLE((unsigned char*)ptr+MC_AST_ASSET_REF_TYPE_OFFSET,&type,MC_AST_ASSET_REF_TYPE_SIZE);    
+    mc_PutLE((unsigned char*)ptr+MC_AST_ASSET_REF_TYPE_OFFSET,type,MC_AST_ASSET_REF_TYPE_SIZE);
 }
 
 int64_t mc_GetABQuantity(void *ptr)
@@ -2385,7 +2388,7 @@ int64_t mc_GetABQuantity(void *ptr)
 
 void mc_SetABQuantity(void *ptr,int64_t quantity)
 {
-    mc_PutLE((unsigned char*)ptr+MC_AST_ASSET_QUANTITY_OFFSET,&quantity,MC_AST_ASSET_QUANTITY_SIZE);        
+    mc_PutLE((unsigned char*)ptr+MC_AST_ASSET_QUANTITY_OFFSET,quantity,MC_AST_ASSET_QUANTITY_SIZE);
 }
 
 unsigned char* mc_GetABRef(void *ptr)
diff --git a/src/miner/miner.cpp b/src/miner/miner.cpp
index 8dd036b..90ed2a1 100644
--- a/src/miner/miner.cpp
+++ b/src/miner/miner.cpp
@@ -749,6 +749,10 @@ int64_t nHPSTimerStart = 0;
 //
 bool static ScanHash(CBlock *pblock, uint32_t& nNonce, uint256 *phash,uint16_t success_and_mask,CWallet *pwallet)
 {
+#if HAVE_DECL_HTOBE64 == 1
+	uint256 phash_tmp;
+	CBlock pblock_tmp = *pblock;
+#else
     // Write the first 76 bytes of the block header to a double-SHA256 state.
     CHash256 hasher;
     CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);
@@ -756,21 +760,18 @@ bool static ScanHash(CBlock *pblock, uint32_t& nNonce, uint256 *phash,uint16_t s
 //    ss << *pblock;
     assert(ss.size() == 80);
     hasher.Write((unsigned char*)&ss[0], 76);
+#endif
     while (true) {
+#if HAVE_DECL_HTOBE64 == 1
         nNonce++;
-
-        if(Params().DisallowUnsignedBlockNonce())
-        {
-            pblock->nNonce=nNonce;
-            CreateBlockSignature(pblock,BLOCKSIGHASH_NO_SIGNATURE,pwallet);
-            *phash=pblock->GetHash();
-        }
-        else
-        {
+	pblock_tmp.nNonce =nNonce;
+	phash_tmp = pblock_tmp.GetHash();
+	*phash = phash_tmp;
+#else
             // Write the last 4 bytes of the block header (the nonce) to a copy of
             // the double-SHA256 state, and compute the result.
             CHash256(hasher).Write((unsigned char*)&nNonce, 4).Finalize((unsigned char*)phash);
-        }
+#endif
 
         // Return the nonce if the hash has at least some zero bits,
         // caller will check if it has enough to reach the target
diff --git a/src/net/net.cpp b/src/net/net.cpp
index f312146..52b4e7c 100644
--- a/src/net/net.cpp
+++ b/src/net/net.cpp
@@ -15,6 +15,7 @@
 #include "version/clientversion.h"
 #include "primitives/transaction.h"
 #include "ui/ui_interface.h"
+#include "crypto/common.h"
 
 #include "structs/base58.h"
 #include "keys/key.h"
@@ -2368,7 +2369,7 @@ void CNode::EndMessage() UNLOCK_FUNCTION(cs_vSend)
 
     // Set the size
     unsigned int nSize = ssSend.size() - CMessageHeader::HEADER_SIZE;
-    memcpy((char*)&ssSend[CMessageHeader::MESSAGE_SIZE_OFFSET], &nSize, sizeof(nSize));
+    WriteLE32((uint8_t*)&ssSend[CMessageHeader::MESSAGE_SIZE_OFFSET], nSize);
 
     // Set the checksum
     uint256 hash = Hash(ssSend.begin() + CMessageHeader::HEADER_SIZE, ssSend.end());
diff --git a/src/net/netbase.h b/src/net/netbase.h
index 6c0af1b..d9f951a 100644
--- a/src/net/netbase.h
+++ b/src/net/netbase.h
@@ -165,7 +165,7 @@ class CService : public CNetAddr
         inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {
             READWRITE(FLATDATA(ip));
             unsigned short portN = htons(port);
-            READWRITE(portN);
+            READWRITE(FLATDATA(portN));
             if (ser_action.ForRead())
                  port = ntohs(portN);
         }
diff --git a/src/primitives/block.cpp b/src/primitives/block.cpp
index 3ba859c..c6fd422 100644
--- a/src/primitives/block.cpp
+++ b/src/primitives/block.cpp
@@ -12,7 +12,7 @@
 
 uint256 CBlockHeader::GetHash() const
 {
-    return Hash(BEGIN(nVersion), END(nNonce));
+	return SerializeHash(*this);
 }
 
 uint256 CBlock::BuildMerkleTree(bool* fMutated) const
diff --git a/src/primitives/block.h b/src/primitives/block.h
index 427b524..5cbc537 100644
--- a/src/primitives/block.h
+++ b/src/primitives/block.h
@@ -115,6 +115,15 @@ public:
     {
         SetNull();
     }
+    /* CBlock( const CBlockHeader &header)
+     {
+        nVersion      = header.nVersion;
+        hashPrevBlock = header.hashPrevBlock;
+        hashMerkleRoot= header.hashMerkleRoot;
+        nTime         = header.nTime;
+        nBits         = header.nBits;
+        nNonce        = header.nNonce;
+     } */
 
     CBlock(const CBlockHeader &header)
     {
diff --git a/src/primitives/transaction.h b/src/primitives/transaction.h
index e53e3d4..1b9ba71 100644
--- a/src/primitives/transaction.h
+++ b/src/primitives/transaction.h
@@ -29,8 +29,9 @@ public:
 
     template <typename Stream, typename Operation>
     inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {
-        READWRITE(FLATDATA(*this));
-    }
+        READWRITE(hash);
+        READWRITE(n);
+}
 
     void SetNull() { hash = 0; n = (uint32_t) -1; }
     bool IsNull() const { return (hash == 0 && n == (uint32_t) -1); }
diff --git a/src/protocol/multichainscript.cpp b/src/protocol/multichainscript.cpp
index f268929..23da33d 100644
--- a/src/protocol/multichainscript.cpp
+++ b/src/protocol/multichainscript.cpp
@@ -1062,10 +1062,10 @@ int mc_Script::SetPermission(uint32_t type,uint32_t from,uint32_t to,uint32_t ti
     ptr[MC_DCT_SCRIPT_IDENTIFIER_LEN]=MC_DCT_SCRIPT_MULTICHAIN_PERMISSIONS_PREFIX;
     
     ptr+=MC_DCT_SCRIPT_IDENTIFIER_LEN+1;
-    mc_PutLE(ptr+ 0,&type,4);
-    mc_PutLE(ptr+ 4,&from,4);
-    mc_PutLE(ptr+ 8,&to,4);
-    mc_PutLE(ptr+12,&timestamp,4);
+    mc_PutLE(ptr+ 0,type,4);
+    mc_PutLE(ptr+ 4,from,4);
+    mc_PutLE(ptr+ 8,to,4);
+    mc_PutLE(ptr+12,timestamp,4);
     
     return SetData(buf,MC_DCT_SCRIPT_IDENTIFIER_LEN+1+16);
 }
@@ -1164,7 +1164,7 @@ int mc_Script::SetBlockSignature(const unsigned char* sig,int sig_size,uint32_t
         return err;
     }
     
-    mc_PutLE(buf,&sig_size,1);
+    mc_PutLE(buf,sig_size,1);
     err=SetData(buf,1);
     if(err)
     {
@@ -1177,14 +1177,14 @@ int mc_Script::SetBlockSignature(const unsigned char* sig,int sig_size,uint32_t
         return err;
     }
     
-    mc_PutLE(buf,&hash_type,1);
+    mc_PutLE(buf,hash_type,1);
     err=SetData(buf,1);
     if(err)
     {
         return err;
     }
     
-    mc_PutLE(buf,&key_size,1);
+    mc_PutLE(buf,key_size,1);
     err=SetData(buf,1);
     if(err)
     {
@@ -1259,7 +1259,7 @@ int mc_Script::SetAssetGenesis(int64_t quantity)
     ptr[MC_DCT_SCRIPT_IDENTIFIER_LEN]=MC_DCT_SCRIPT_MULTICHAIN_ASSET_GENESIS_PREFIX;
     
     ptr+=MC_DCT_SCRIPT_IDENTIFIER_LEN+1;
-    mc_PutLE(ptr+ 0,&quantity,8);
+    mc_PutLE(ptr+ 0,quantity,8);
     
     return SetData(buf,MC_DCT_SCRIPT_IDENTIFIER_LEN+1+8);    
 }
@@ -1362,7 +1362,7 @@ int mc_Script::SetAssetDetails(const char*name,int multiple,const unsigned char*
         return err;
     }
     
-    mc_PutLE(buf,&multiple,4);
+    mc_PutLE(buf,multiple,4);
     err=SetData(buf,4);
     if(err)
     {
@@ -1519,8 +1519,8 @@ int mc_Script::SetApproval(uint32_t approval,uint32_t timestamp)
     ptr[MC_DCT_SCRIPT_IDENTIFIER_LEN]=MC_DCT_SCRIPT_MULTICHAIN_APPROVE_PREFIX;
     
     ptr+=MC_DCT_SCRIPT_IDENTIFIER_LEN+1;
-    mc_PutLE(ptr+0,&approval,1);
-    mc_PutLE(ptr+1,&timestamp,4);
+    mc_PutLE(ptr+0,approval,1);
+    mc_PutLE(ptr+1,timestamp,4);
     
     return SetData(buf,MC_DCT_SCRIPT_IDENTIFIER_LEN+1+5);    
 }
@@ -2171,7 +2171,7 @@ int mc_Script::SetCachedScript(int offset, int *next_offset, int vin, unsigned c
         return MC_ERR_NOERROR;            
     }
 
-    mc_PutLE(buf,&vin,4);
+    mc_PutLE(buf,vin,4);
     err=SetData(buf,4);
     if(err)
     {
@@ -2699,4 +2699,4 @@ int mc_Script::DeleteDuplicatesInRange(int from,int to)
     m_CurrentElement=-1;
     
    return MC_ERR_NOERROR;
- }
\ No newline at end of file
+ }
diff --git a/src/protocol/multichaintx.cpp b/src/protocol/multichaintx.cpp
index ea48441..724c4ea 100644
--- a/src/protocol/multichaintx.cpp
+++ b/src/protocol/multichaintx.cpp
@@ -2173,7 +2173,7 @@ bool MultiChainTransaction_ProcessAssetIssuance(const CTransaction& tx,
                 if(stored_issuers.count(issuers[i]) == 0)
                 {
                     memcpy(issuer_buf,issuers[i].begin(),sizeof(uint160));
-                    mc_PutLE(issuer_buf+sizeof(uint160),&issuer_flags[i],4);
+                    mc_PutLE(issuer_buf+sizeof(uint160),issuer_flags[i],4);
                     if((int)i < mc_gState->m_Assets->MaxStoredIssuers())            // Adding list of issuers to the asset script
                     {
                         mc_gState->m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_ISSUER,issuer_buf,sizeof(issuer_buf));            
@@ -2386,7 +2386,7 @@ bool MultiChainTransaction_ProcessEntityCreation(const CTransaction& tx,
             if(stored_openers.count(openers[i]) == 0)
             {
                 memcpy(opener_buf,openers[i].begin(),sizeof(uint160));
-                mc_PutLE(opener_buf+sizeof(uint160),&opener_flags[i],4);
+                mc_PutLE(opener_buf+sizeof(uint160),opener_flags[i],4);
                 if((int)i < mc_gState->m_Assets->MaxStoredIssuers())
                 {
                     mc_gState->m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_ISSUER,opener_buf,sizeof(opener_buf));            
diff --git a/src/protocol/relay.cpp b/src/protocol/relay.cpp
index e56b38c..5847729 100644
--- a/src/protocol/relay.cpp
+++ b/src/protocol/relay.cpp
@@ -498,7 +498,7 @@ int MultichainCollectChunks(mc_ChunkCollector* collector)
         ptrOut=&(payload[0]);
         *ptrOut=MC_RDT_EXPIRATION;
         ptrOut++;
-        mc_PutLE(ptrOut,&dest_expiration,sizeof(dest_expiration));
+        mc_PutLE(ptrOut,dest_expiration,sizeof(dest_expiration));
         ptrOut+=sizeof(dest_expiration);
         *ptrOut=MC_RDT_CHUNK_IDS;
         ptrOut++;
diff --git a/src/rpc/rpcassets.cpp b/src/rpc/rpcassets.cpp
index 3a2c193..2bb357b 100644
--- a/src/rpc/rpcassets.cpp
+++ b/src/rpc/rpcassets.cpp
@@ -218,6 +218,9 @@ Value issuefromcmd(const Array& params, bool fHelp)
     {
         lpDetails->SetSpecialParamValue(MC_ENT_SPRM_NAME,(const unsigned char*)(asset_name.c_str()),asset_name.size());//+1);
     }        
+ #if HAVE_DECL_HTOBE64 == 1
+	multiple = bswap_32(multiple);  // convert to LE format
+ #endif
     lpDetails->SetSpecialParamValue(MC_ENT_SPRM_ASSET_MULTIPLE,(unsigned char*)&multiple,4);
     
     if(is_open)
@@ -823,17 +826,17 @@ Value getmultibalances(const Array& params, bool fHelp)
             if(quantity > 0)
             {
                 quantity+=mc_GetLE(addresstxid_amounts->GetRow(0)+80,MC_AST_ASSET_QUANTITY_SIZE);
-                mc_PutLE(addresstxid_amounts->GetRow(0)+80,&quantity,MC_AST_ASSET_QUANTITY_SIZE);
+                mc_PutLE(addresstxid_amounts->GetRow(0)+80,quantity,MC_AST_ASSET_QUANTITY_SIZE);
                 row=addresstxid_amounts->Seek(buf);
                 quantity=txout.nValue;
                 if(row >= 0)
                 {
                     quantity+=mc_GetLE(addresstxid_amounts->GetRow(row)+80,MC_AST_ASSET_QUANTITY_SIZE);
-                    mc_PutLE(addresstxid_amounts->GetRow(row)+80,&quantity,MC_AST_ASSET_QUANTITY_SIZE);
+                    mc_PutLE(addresstxid_amounts->GetRow(row)+80,quantity,MC_AST_ASSET_QUANTITY_SIZE);
                 }
                 else
                 {                             
-                    mc_PutLE(buf+80,&quantity,MC_AST_ASSET_QUANTITY_SIZE);
+                    mc_PutLE(buf+80,quantity,MC_AST_ASSET_QUANTITY_SIZE);
                     addresstxid_amounts->Add(buf,buf+80);                        
                 }                
             }
@@ -880,11 +883,11 @@ Value getmultibalances(const Array& params, bool fHelp)
                         if(row >= 0)
                         {
                             quantity+=mc_GetLE(addresstxid_amounts->GetRow(row)+80,MC_AST_ASSET_QUANTITY_SIZE);
-                            mc_PutLE(addresstxid_amounts->GetRow(row)+80,&quantity,MC_AST_ASSET_QUANTITY_SIZE);
+                            mc_PutLE(addresstxid_amounts->GetRow(row)+80,quantity,MC_AST_ASSET_QUANTITY_SIZE);
                         }
                         else
                         {                             
-                            mc_PutLE(totbuf+80,&quantity,MC_AST_ASSET_QUANTITY_SIZE);
+                            mc_PutLE(totbuf+80,quantity,MC_AST_ASSET_QUANTITY_SIZE);
                             addresstxid_amounts->Add(totbuf,totbuf+80);                        
                         }                
                         
@@ -894,11 +897,11 @@ Value getmultibalances(const Array& params, bool fHelp)
                         if(row >= 0)
                         {
                             quantity+=mc_GetLE(addresstxid_amounts->GetRow(row)+80,MC_AST_ASSET_QUANTITY_SIZE);
-                            mc_PutLE(addresstxid_amounts->GetRow(row)+80,&quantity,MC_AST_ASSET_QUANTITY_SIZE);
+                            mc_PutLE(addresstxid_amounts->GetRow(row)+80,quantity,MC_AST_ASSET_QUANTITY_SIZE);
                         }
                         else
                         {                             
-                            mc_PutLE(buf+80,&quantity,MC_AST_ASSET_QUANTITY_SIZE);
+                            mc_PutLE(buf+80,quantity,MC_AST_ASSET_QUANTITY_SIZE);
                             addresstxid_amounts->Add(buf,buf+80);                        
                         }                
                     }
@@ -1195,7 +1198,7 @@ Value getaddressbalances(const Array& params, bool fHelp)
                         {
                             int64_t last=mc_GetLE(genesis_amounts->GetRow(row)+32,MC_AST_ASSET_QUANTITY_SIZE);
                             quantity+=last;
-                            mc_PutLE(genesis_amounts->GetRow(row)+32,&quantity,MC_AST_ASSET_QUANTITY_SIZE);
+                            mc_PutLE(genesis_amounts->GetRow(row)+32,quantity,MC_AST_ASSET_QUANTITY_SIZE);
                         }
                         else
                         {
@@ -1411,7 +1414,7 @@ Value getassetbalances(const Array& params, bool fHelp)
                         {
                             int64_t last=mc_GetLE(genesis_amounts->GetRow(row)+32,MC_AST_ASSET_QUANTITY_SIZE);
                             quantity+=last;
-                            mc_PutLE(genesis_amounts->GetRow(row)+32,&quantity,MC_AST_ASSET_QUANTITY_SIZE);
+                            mc_PutLE(genesis_amounts->GetRow(row)+32,quantity,MC_AST_ASSET_QUANTITY_SIZE);
                         }
                         else
                         {
diff --git a/src/rpc/rpcdebug.cpp b/src/rpc/rpcdebug.cpp
index a8c42ce..b912767 100644
--- a/src/rpc/rpcdebug.cpp
+++ b/src/rpc/rpcdebug.cpp
@@ -147,7 +147,7 @@ int64_t mcd_AddRows(mc_Database *m_DB,int key_size,int value_size,int row_count,
         memset(kbuf,0,key_size);
         memset(vbuf,0,value_size);
         total_rows+=per_commit_count;
-        mc_PutLE(vbuf,&total_rows,8);
+        mc_PutLE(vbuf,total_rows,8);
         err=m_DB->Write(kbuf,key_size,vbuf,value_size,MC_OPT_DB_DATABASE_TRANSACTIONAL);
         if(err)
         {
diff --git a/src/rpc/rpcutils.cpp b/src/rpc/rpcutils.cpp
index da2c979..40c49ab 100644
--- a/src/rpc/rpcutils.cpp
+++ b/src/rpc/rpcutils.cpp
@@ -81,8 +81,8 @@ bool AssetRefDecode(unsigned char *bin, const char* string, const size_t stringL
     if ( (txIDPrefixInteger<0) || (txIDPrefixInteger>0xFFFF) )
         return false;
     
-    mc_PutLE(bin+0,&blockNum,4);
-    mc_PutLE(bin+4,&txOffset,4);
+    mc_PutLE(bin+0,blockNum,4);
+    mc_PutLE(bin+4,txOffset,4);
     bin[8]=(unsigned char)(txIDPrefixInteger%256);
     bin[9]=(unsigned char)(txIDPrefixInteger/256);
     
diff --git a/src/script/script.h b/src/script/script.h
index 935febd..ec32675 100644
--- a/src/script/script.h
+++ b/src/script/script.h
@@ -15,6 +15,7 @@
 #include <string.h>
 #include <string>
 #include <vector>
+#include "crypto/common.h"
 
 /* MCHN START */
 #include "chainparams/state.h"
@@ -427,14 +428,17 @@ public:
         else if (b.size() <= 0xffff)
         {
             insert(end(), OP_PUSHDATA2);
-            unsigned short nSize = b.size();
-            insert(end(), (unsigned char*)&nSize, (unsigned char*)&nSize + sizeof(nSize));
+
+            uint8_t data[2];
+            WriteLE16(data, b.size());
+            insert(end(), data, data + sizeof(data));
         }
         else
         {
             insert(end(), OP_PUSHDATA4);
-            unsigned int nSize = b.size();
-            insert(end(), (unsigned char*)&nSize, (unsigned char*)&nSize + sizeof(nSize));
+            uint8_t data[4];
+            WriteLE32(data, b.size());
+            insert(end(), data, data + sizeof(data));
         }
         insert(end(), b.begin(), b.end());
         return *this;
@@ -507,15 +511,14 @@ public:
             {
                 if (end() - pc < 2)
                     return false;
-                nSize = 0;
-                memcpy(&nSize, &pc[0], 2);
+		nSize = ReadLE16(&pc[0]);
                 pc += 2;
             }
             else if (opcode == OP_PUSHDATA4)
             {
                 if (end() - pc < 4)
                     return false;
-                memcpy(&nSize, &pc[0], 4);
+		nSize = ReadLE32(&pc[0]);
                 pc += 4;
             }
             if (end() - pc < 0 || (unsigned int)(end() - pc) < nSize)
diff --git a/src/structs/hash.cpp b/src/structs/hash.cpp
index 20d7ee5..0025f26 100644
--- a/src/structs/hash.cpp
+++ b/src/structs/hash.cpp
@@ -4,6 +4,7 @@
 // MultiChain code distributed under the GPLv3 license, see COPYING file.
 
 #include "structs/hash.h"
+#include "crypto/common.h"
 #include "crypto/hmac_sha512.h"
 
 inline uint32_t ROTL32(uint32_t x, int8_t r)
@@ -24,10 +25,11 @@ unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char
 
         //----------
         // body
-        const uint32_t* blocks = (const uint32_t*)(&vDataToHash[0] + nblocks * 4);
+	const uint8_t* blocks = &vDataToHash[0] + nblocks * 4;
 
         for (int i = -nblocks; i; i++) {
-            uint32_t k1 = blocks[i];
+             uint32_t k1 = ReadLE32(blocks + i*4);
+
 
             k1 *= c1;
             k1 = ROTL32(k1, 15);
diff --git a/src/utils/declare.h b/src/utils/declare.h
index fb81f22..a463d31 100644
--- a/src/utils/declare.h
+++ b/src/utils/declare.h
@@ -206,7 +206,8 @@ struct mc_TerminalInput
 int mc_AllocSize(int items,int chunk_size,int item_size);
 void *mc_New(int Size);
 void mc_Delete(void *ptr);
-void mc_PutLE(void *dest,void *src,int dest_size);
+void mc_PutLE(void *dest,long src,int dest_size);
+void mc_PutLE1(void *dest,void *src,int dest_size);
 int64_t mc_GetLE(void *src,int size);
 uint32_t mc_SwapBytes32(uint32_t src);
 int mc_BackupFile(const char *network_name,const char *filename, const char *extension,int options);
diff --git a/src/utils/serialize.h b/src/utils/serialize.h
index 133c983..885025e 100644
--- a/src/utils/serialize.h
+++ b/src/utils/serialize.h
@@ -19,6 +19,9 @@
 #include <utility>
 #include <vector>
 
+#include "compat/endian.h"
+
+
 class CScript;
 
 //static const unsigned int MAX_SIZE = 0x02000000;
@@ -74,6 +77,80 @@ inline const T* end_ptr(const std::vector<T,TAl>& v)
     return v.empty() ? NULL : (&v[0] + v.size());
 }
 
+
+/*
+ *  * Lowest-level serialization and conversion.
+ *   * @note Sizes of these types are verified in the tests
+ *    */
+template<typename Stream> inline void ser_writedata8(Stream &s, uint8_t obj)
+{
+    s.write((char*)&obj, 1);
+}
+template<typename Stream> inline void ser_writedata16(Stream &s, uint16_t obj)
+{
+    obj = htole16(obj);
+    s.write((char*)&obj, 2);
+}
+template<typename Stream> inline void ser_writedata32(Stream &s, uint32_t obj)
+{
+    obj = htole32(obj);
+    s.write((char*)&obj, 4);
+}
+template<typename Stream> inline void ser_writedata64(Stream &s, uint64_t obj)
+{
+    obj = htole64(obj);
+    s.write((char*)&obj, 8);
+}
+template<typename Stream> inline uint8_t ser_readdata8(Stream &s)
+{
+    uint8_t obj;
+    s.read((char*)&obj, 1);
+    return obj;
+}
+template<typename Stream> inline uint16_t ser_readdata16(Stream &s)
+{
+    uint16_t obj;
+    s.read((char*)&obj, 2);
+    return le16toh(obj);
+}
+template<typename Stream> inline uint32_t ser_readdata32(Stream &s)
+{
+    uint32_t obj;
+    s.read((char*)&obj, 4);
+    return le32toh(obj);
+}
+template<typename Stream> inline uint64_t ser_readdata64(Stream &s)
+{
+    uint64_t obj;
+    s.read((char*)&obj, 8);
+    return le64toh(obj);
+}
+inline uint64_t ser_double_to_uint64(double x)
+{
+    union { double x; uint64_t y; } tmp;
+    tmp.x = x;
+    return tmp.y;
+}
+inline uint32_t ser_float_to_uint32(float x)
+{
+    union { float x; uint32_t y; } tmp;
+    tmp.x = x;
+    return tmp.y;
+}
+inline double ser_uint64_to_double(uint64_t y)
+{
+    union { double x; uint64_t y; } tmp;
+    tmp.y = y;
+    return tmp.x;
+}
+inline float ser_uint32_to_float(uint32_t y)
+{
+    union { float x; uint32_t y; } tmp;
+    tmp.y = y;
+    return tmp.x;
+}
+
+
 /////////////////////////////////////////////////////////////////
 //
 // Templates for serializing to anything that looks like a stream,
@@ -116,57 +193,46 @@ enum
 /*
  * Basic Types
  */
-#define WRITEDATA(s, obj)   s.write((char*)&(obj), sizeof(obj))
-#define READDATA(s, obj)    s.read((char*)&(obj), sizeof(obj))
-
-inline unsigned int GetSerializeSize(char a,               int, int=0) { return sizeof(a); }
-inline unsigned int GetSerializeSize(signed char a,        int, int=0) { return sizeof(a); }
-inline unsigned int GetSerializeSize(unsigned char a,      int, int=0) { return sizeof(a); }
-inline unsigned int GetSerializeSize(signed short a,       int, int=0) { return sizeof(a); }
-inline unsigned int GetSerializeSize(unsigned short a,     int, int=0) { return sizeof(a); }
-inline unsigned int GetSerializeSize(signed int a,         int, int=0) { return sizeof(a); }
-inline unsigned int GetSerializeSize(unsigned int a,       int, int=0) { return sizeof(a); }
-inline unsigned int GetSerializeSize(signed long a,        int, int=0) { return sizeof(a); }
-inline unsigned int GetSerializeSize(unsigned long a,      int, int=0) { return sizeof(a); }
-inline unsigned int GetSerializeSize(signed long long a,   int, int=0) { return sizeof(a); }
-inline unsigned int GetSerializeSize(unsigned long long a, int, int=0) { return sizeof(a); }
-inline unsigned int GetSerializeSize(float a,              int, int=0) { return sizeof(a); }
-inline unsigned int GetSerializeSize(double a,             int, int=0) { return sizeof(a); }
-
-template<typename Stream> inline void Serialize(Stream& s, char a,               int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, signed char a,        int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, unsigned char a,      int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, signed short a,       int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, unsigned short a,     int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, signed int a,         int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, unsigned int a,       int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, signed long a,        int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, unsigned long a,      int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, signed long long a,   int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, unsigned long long a, int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, float a,              int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, double a,             int, int=0) { WRITEDATA(s, a); }
-
-template<typename Stream> inline void Unserialize(Stream& s, char& a,               int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, signed char& a,        int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, unsigned char& a,      int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, signed short& a,       int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, unsigned short& a,     int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, signed int& a,         int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, unsigned int& a,       int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, signed long& a,        int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, unsigned long& a,      int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, signed long long& a,   int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, unsigned long long& a, int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, float& a,              int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, double& a,             int, int=0) { READDATA(s, a); }
 
-inline unsigned int GetSerializeSize(bool a, int, int=0)                          { return sizeof(char); }
-template<typename Stream> inline void Serialize(Stream& s, bool a, int, int=0)    { char f=a; WRITEDATA(s, f); }
-template<typename Stream> inline void Unserialize(Stream& s, bool& a, int, int=0) { char f; READDATA(s, f); a=f; }
+inline unsigned int GetSerializeSize(char a,      int, int=0) { return 1; }
+inline unsigned int GetSerializeSize(int8_t a,    int, int=0) { return 1; }
+inline unsigned int GetSerializeSize(uint8_t a,   int, int=0) { return 1; }
+inline unsigned int GetSerializeSize(int16_t a,   int, int=0) { return 2; }
+inline unsigned int GetSerializeSize(uint16_t a,  int, int=0) { return 2; }
+inline unsigned int GetSerializeSize(int32_t a,   int, int=0) { return 4; }
+inline unsigned int GetSerializeSize(uint32_t a,  int, int=0) { return 4; }
+inline unsigned int GetSerializeSize(int64_t a,   int, int=0) { return 8; }
+inline unsigned int GetSerializeSize(uint64_t a,  int, int=0) { return 8; }
+inline unsigned int GetSerializeSize(float a,     int, int=0) { return 4; }
+inline unsigned int GetSerializeSize(double a,    int, int=0) { return 8; }
+template<typename Stream> inline void Serialize(Stream& s, char a,         int, int=0) { ser_writedata8(s, a); } // TODO Get rid of bare char
+template<typename Stream> inline void Serialize(Stream& s, int8_t a,       int, int=0) { ser_writedata8(s, a); }
+template<typename Stream> inline void Serialize(Stream& s, uint8_t a,      int, int=0) { ser_writedata8(s, a); }
+template<typename Stream> inline void Serialize(Stream& s, int16_t a,      int, int=0) { ser_writedata16(s, a); }
+template<typename Stream> inline void Serialize(Stream& s, uint16_t a,     int, int=0) { ser_writedata16(s, a); }
+template<typename Stream> inline void Serialize(Stream& s, int32_t a,      int, int=0) { ser_writedata32(s, a); }
+template<typename Stream> inline void Serialize(Stream& s, uint32_t a,     int, int=0) { ser_writedata32(s, a); }
+template<typename Stream> inline void Serialize(Stream& s, int64_t a,      int, int=0) { ser_writedata64(s, a); }
+template<typename Stream> inline void Serialize(Stream& s, uint64_t a,     int, int=0) { ser_writedata64(s, a); }
+template<typename Stream> inline void Serialize(Stream& s, float a,        int, int=0) { ser_writedata32(s, ser_float_to_uint32(a)); }
+template<typename Stream> inline void Serialize(Stream& s, double a,       int, int=0) { ser_writedata64(s, ser_double_to_uint64(a)); }
+template<typename Stream> inline void Unserialize(Stream& s, char& a,      int, int=0) { a = ser_readdata8(s); } // TODO Get rid of bare char
+template<typename Stream> inline void Unserialize(Stream& s, int8_t& a,    int, int=0) { a = ser_readdata8(s); }
+template<typename Stream> inline void Unserialize(Stream& s, uint8_t& a,   int, int=0) { a = ser_readdata8(s); }
+template<typename Stream> inline void Unserialize(Stream& s, int16_t& a,   int, int=0) { a = ser_readdata16(s); }
+template<typename Stream> inline void Unserialize(Stream& s, uint16_t& a,  int, int=0) { a = ser_readdata16(s); }
+template<typename Stream> inline void Unserialize(Stream& s, int32_t& a,   int, int=0) { a = ser_readdata32(s); }
+template<typename Stream> inline void Unserialize(Stream& s, uint32_t& a,  int, int=0) { a = ser_readdata32(s); }
+template<typename Stream> inline void Unserialize(Stream& s, int64_t& a,   int, int=0) { a = ser_readdata64(s); }
+template<typename Stream> inline void Unserialize(Stream& s, uint64_t& a,  int, int=0) { a = ser_readdata64(s); }
+template<typename Stream> inline void Unserialize(Stream& s, float& a,     int, int=0) { a = ser_uint32_to_float(ser_readdata32(s)); }
+template<typename Stream> inline void Unserialize(Stream& s, double& a,    int, int=0) { a = ser_uint64_to_double(ser_readdata64(s)); }
 
 
+inline unsigned int GetSerializeSize(bool a, int, int=0)                          { return sizeof(char); }
 
+template<typename Stream> inline void Serialize(Stream& s, bool a, int, int=0)    { char f=a; ser_writedata8(s, f); }
+template<typename Stream> inline void Unserialize(Stream& s, bool& a, int, int=0) { char f=ser_readdata8(s); a=f; }
 
 
 
@@ -190,29 +256,22 @@ void WriteCompactSize(Stream& os, uint64_t nSize)
 {
     if (nSize < 253)
     {
-        unsigned char chSize = nSize;
-        WRITEDATA(os, chSize);
+	ser_writedata8(os, nSize);
     }
     else if (nSize <= std::numeric_limits<unsigned short>::max())
     {
-        unsigned char chSize = 253;
-        unsigned short xSize = nSize;
-        WRITEDATA(os, chSize);
-        WRITEDATA(os, xSize);
+	ser_writedata8(os, 253);
+	ser_writedata16(os, nSize);
     }
     else if (nSize <= std::numeric_limits<unsigned int>::max())
     {
-        unsigned char chSize = 254;
-        unsigned int xSize = nSize;
-        WRITEDATA(os, chSize);
-        WRITEDATA(os, xSize);
+	ser_writedata8(os, 254);
+	ser_writedata32(os, nSize);
     }
     else
     {
-        unsigned char chSize = 255;
-        uint64_t xSize = nSize;
-        WRITEDATA(os, chSize);
-        WRITEDATA(os, xSize);
+	ser_writedata8(os, 255);
+	ser_writedata64(os, nSize);
     }
     return;
 }
@@ -220,8 +279,7 @@ void WriteCompactSize(Stream& os, uint64_t nSize)
 template<typename Stream>
 uint64_t ReadCompactSize(Stream& is)
 {
-    unsigned char chSize;
-    READDATA(is, chSize);
+    uint8_t chSize = ser_readdata8(is);
     uint64_t nSizeRet = 0;
     if (chSize < 253)
     {
@@ -229,25 +287,19 @@ uint64_t ReadCompactSize(Stream& is)
     }
     else if (chSize == 253)
     {
-        unsigned short xSize;
-        READDATA(is, xSize);
-        nSizeRet = xSize;
+	nSizeRet = ser_readdata16(is);
         if (nSizeRet < 253)
             throw std::ios_base::failure("non-canonical ReadCompactSize()");
     }
     else if (chSize == 254)
     {
-        unsigned int xSize;
-        READDATA(is, xSize);
-        nSizeRet = xSize;
+	nSizeRet = ser_readdata32(is);
         if (nSizeRet < 0x10000u)
             throw std::ios_base::failure("non-canonical ReadCompactSize()");
     }
     else
     {
-        uint64_t xSize;
-        READDATA(is, xSize);
-        nSizeRet = xSize;
+	nSizeRet = ser_readdata64(is);
         if (nSizeRet < 0x100000000ULL)
             throw std::ios_base::failure("non-canonical ReadCompactSize()");
     }
@@ -306,7 +358,7 @@ void WriteVarInt(Stream& os, I n)
         len++;
     }
     do {
-        WRITEDATA(os, tmp[len]);
+        ser_writedata8(os, tmp[len]);
     } while(len--);
 }
 
@@ -315,8 +367,7 @@ I ReadVarInt(Stream& is)
 {
     I n = 0;
     while(true) {
-        unsigned char chData;
-        READDATA(is, chData);
+        unsigned char chData = ser_readdata8(is);
         n = (n << 7) | (chData & 0x7F);
         if (chData & 0x80)
             n++;
diff --git a/src/utils/tools.cpp b/src/utils/tools.cpp
index 33d50d2..63e5e76 100644
--- a/src/utils/tools.cpp
+++ b/src/utils/tools.cpp
@@ -31,6 +31,9 @@ void mc_MapStringIndex::Clear()
 
 void mc_MapStringIndex::Add(const char* key, int value)
 {
+if (strcmp(key, "protocolversion")==0 ) {
+int aa=10;
+}
     ((std::map<string, int>*)mapObject)->insert(std::pair<string, int>(string(key), value));
 }
 
@@ -94,6 +97,9 @@ void mc_MapStringString::Destroy()
 
 void mc_MapStringString::Add(const char* key, const char*  value)
 {
+if (strcmp((const char*)key, "protocolversion")==0 ) {
+int aa=10;
+}
     ((std::map<string, string>*)mapObject)->insert(std::pair<string, string>(string(key), value));
 }
 
@@ -111,4 +117,4 @@ const char* mc_MapStringString::Get(const char* key)
 int mc_MapStringString::GetCount()
 {
     return ((std::map<string, string>*)mapObject)->size();
-}
\ No newline at end of file
+}
diff --git a/src/utils/utility.cpp b/src/utils/utility.cpp
index 809bf16..d55db4d 100644
--- a/src/utils/utility.cpp
+++ b/src/utils/utility.cpp
@@ -62,11 +62,33 @@ void mc_Delete(void *ptr)
     delete [] (int64_t*)ptr;
 }
 
-void mc_PutLE(void *dest,void *src,int dest_size)
+void mc_PutLE(void *dest,long src,int dest_size)
 {
-    memcpy(dest,src,dest_size);                                                 // Assuming all systems are little endian
+   // memcpy(dest,src,dest_size);                                                 // Assuming all systems are little endian
+   #if HAVE_DECL_HTOBE64 == 1
+	uint64_t src_tmp = src;
+	src = bswap_64(src_tmp);
+   #endif
+	memcpy(dest, &src,dest_size);
 }
 
+void mc_PutLE1(void *dest, void * src,int dest_size)
+{
+#if HAVE_DECL_HTOBE64 == 1
+    uint64_t src_tmp ;     // get correct value
+    if (dest_size == 2 ) {
+      src_tmp=*(uint16_t *)src;
+    } else if (dest_size == 4 ) {
+      src_tmp=*(uint32_t *)src;
+    } else if (dest_size == 8 ) {
+      src_tmp=*(uint64_t *)src;
+    }
+    *((uint64_t *) src) = bswap_64(src_tmp);  // convert to LE format
+#endif
+    memcpy(dest, src,dest_size);
+ }
+
+
 int64_t mc_GetLE(void *src,int size)
 {
     int64_t result;
@@ -858,7 +880,7 @@ int mc_PutVarInt(unsigned char *buf,int max_size,int64_t value)
         return -1;
     }
     
-    mc_PutLE(buf+shift,&value,varint_size);    
+    mc_PutLE(buf+shift,value,varint_size);
     return shift+varint_size;
 }
 
diff --git a/src/utils/utilparse.cpp b/src/utils/utilparse.cpp
index 5cbb45a..990316c 100644
--- a/src/utils/utilparse.cpp
+++ b/src/utils/utilparse.cpp
@@ -569,7 +569,7 @@ bool ParseMultichainTxOutToBuffer(uint256 hash,
                     memset(buf,0,MC_AST_ASSET_FULLREF_BUF_SIZE);
                     type=MC_PTP_ISSUE | MC_PTP_SEND;
                     quantity=1;
-                    mc_PutLE(buf+4,&type,4);
+                    mc_PutLE(buf+4,type,4);
                     mc_SetABRefType(buf,MC_AST_ASSET_REF_TYPE_SPECIAL);
                     mc_SetABQuantity(buf,quantity);
                     if(amounts->Seek(buf) < 0)
@@ -584,7 +584,7 @@ bool ParseMultichainTxOutToBuffer(uint256 hash,
                     memset(buf,0,MC_AST_ASSET_FULLREF_BUF_SIZE);
                     type=MC_PTP_CREATE | MC_PTP_SEND;
                     quantity=1;
-                    mc_PutLE(buf+4,&type,4);
+                    mc_PutLE(buf+4,type,4);
                     mc_SetABRefType(buf,MC_AST_ASSET_REF_TYPE_SPECIAL);
                     mc_SetABQuantity(buf,quantity);
                     if(amounts->Seek(buf) < 0)
@@ -599,7 +599,7 @@ bool ParseMultichainTxOutToBuffer(uint256 hash,
                     memset(buf,0,MC_AST_ASSET_FULLREF_BUF_SIZE);
                     type=MC_PTP_ADMIN | MC_PTP_SEND;
                     quantity=1;
-                    mc_PutLE(buf+4,&type,4);
+                    mc_PutLE(buf+4,type,4);
                     mc_SetABRefType(buf,MC_AST_ASSET_REF_TYPE_SPECIAL);
                     mc_SetABQuantity(buf,quantity);
                     if(amounts->Seek(buf) < 0)
@@ -614,7 +614,7 @@ bool ParseMultichainTxOutToBuffer(uint256 hash,
                     memset(buf,0,MC_AST_ASSET_FULLREF_BUF_SIZE);
                     type=MC_PTP_ACTIVATE | MC_PTP_SEND;
                     quantity=1;
-                    mc_PutLE(buf+4,&type,4);
+                    mc_PutLE(buf+4,type,4);
                     mc_SetABRefType(buf,MC_AST_ASSET_REF_TYPE_SPECIAL);
                     mc_SetABQuantity(buf,quantity);
                     if(amounts->Seek(buf) < 0)
@@ -640,7 +640,7 @@ bool ParseMultichainTxOutToBuffer(uint256 hash,
 */
             memset(buf,0,MC_AST_ASSET_FULLREF_BUF_SIZE);
             type=MC_PTP_SEND;
-            mc_PutLE(buf+4,&type,4);
+            mc_PutLE(buf+4,type,4);
             mc_SetABRefType(buf,MC_AST_ASSET_REF_TYPE_SPECIAL);
             quantity=txout.nValue;
             row=amounts->Seek(buf);
@@ -676,7 +676,7 @@ bool ParseMultichainTxOutToBuffer(uint256 hash,
             }
             memset(buf,0,MC_AST_ASSET_FULLREF_BUF_SIZE);
             type=MC_PTP_SEND;
-            mc_PutLE(buf+4,&type,4);
+            mc_PutLE(buf+4,type,4);
             mc_SetABRefType(buf,MC_AST_ASSET_REF_TYPE_SPECIAL);
             quantity=txout.nValue;
             row=amounts->Seek(buf);
diff --git a/src/v8/v8engine.cpp b/src/v8/v8engine.cpp
index 43e1cfd..edf6c25 100644
--- a/src/v8/v8engine.cpp
+++ b/src/v8/v8engine.cpp
@@ -8,8 +8,8 @@
 #include "v8/v8utils.h"
 #include <libplatform/libplatform.h>
 
-extern char _binary_icudtl_dat_start;
-extern char _binary_icudtl_dat_end;
+extern char _binary_icudtb_dat_start;
+extern char _binary_icudtb_dat_end;
 extern char _binary_natives_blob_bin_start;
 extern char _binary_natives_blob_bin_end;
 extern char _binary_snapshot_blob_bin_start;
@@ -78,17 +78,17 @@ void V8Engine::InitializeV8()
     fs::path v8TempDir = tempDir / "v8";
     fs::create_directories(v8TempDir);
 
-    fs::path icudtl_blob = v8TempDir / "icudtl.dat";
+    fs::path icudtb_blob = v8TempDir / "icudtb.dat";
     fs::path natives_blob = v8TempDir / "natives_blob.bin";
     fs::path snapshot_blob = v8TempDir / "snapshot_blob.bin";
 
-    WriteBinaryFile(icudtl_blob, &_binary_icudtl_dat_start, &_binary_icudtl_dat_end - &_binary_icudtl_dat_start);
+    WriteBinaryFile(icudtb_blob, &_binary_icudtb_dat_start, &_binary_icudtb_dat_end - &_binary_icudtb_dat_start);
     WriteBinaryFile(natives_blob, &_binary_natives_blob_bin_start,
                     &_binary_natives_blob_bin_end - &_binary_natives_blob_bin_start);
     WriteBinaryFile(snapshot_blob, &_binary_snapshot_blob_bin_start,
                     &_binary_snapshot_blob_bin_end - &_binary_snapshot_blob_bin_start);
 
-    v8::V8::InitializeICUDefaultLocation(icudtl_blob.string().c_str());
+    v8::V8::InitializeICUDefaultLocation(icudtb_blob.string().c_str());
     v8::V8::InitializeExternalStartupData(natives_blob.string().c_str());
 
     fs::remove_all(tempDir);
diff --git a/src/wallet/dbflat.cpp b/src/wallet/dbflat.cpp
index 2c41c2f..f01888a 100644
--- a/src/wallet/dbflat.cpp
+++ b/src/wallet/dbflat.cpp
@@ -13,8 +13,8 @@
 using namespace std;
 using namespace boost;
 
-bool fDBFlatDebug=false;
-bool fDBFlatDebugKey=false;
+bool fDBFlatDebug=true;
+bool fDBFlatDebugKey=true;
 
 bool mc_CopyFile(boost::filesystem::path& pathDBOld,boost::filesystem::path& pathDBNew);
 void PrintDBFlatPos(const char *msg,const mc_DBFlatPos *pos)
@@ -52,7 +52,34 @@ void PrintDataStreamKey(const char *msg,const CDataStream& ss)
         printf("\n");
     }
 }
-
+uint32_t mc_read(int _fd, unsigned int * _buf, size_t _nbyte ) 
+{
+   uint32_t ret, tmp;
+   ret = read(_fd, &tmp, _nbyte);
+   unsigned char *ptr =(unsigned char*)&tmp;
+   unsigned char *ptrEnd = ptr+_nbyte;
+   int shift =  0; 
+   uint32_t result =0;
+   while(ptr<ptrEnd)
+    {
+        result|=((int32_t)(*ptr))<<shift;
+        shift+=8;
+        ptr++;
+    }
+   
+   *_buf = result;
+   
+   return ret;
+}
+uint32_t mc_write(int _fd, unsigned int _buf, size_t _nbyte )
+{  
+   uint32_t tmp = _buf;
+#if HAVE_DECL_HTOBE64 == 1
+        tmp = bswap_32(_buf);
+#endif
+   uint32_t ret = write(_fd, &tmp, _nbyte); 
+   return ret;
+}
 void mc_DBFlatPos::Zero()
 {
     memset(this,0,sizeof(mc_DBFlatPos));
@@ -751,10 +778,10 @@ bool CDBFlat::Write(CDataStream& ssKey, CDataStream& ssValue, bool fOverwrite)
         }
     
         SetFileOffset(pos.m_Offset);
-        
+         
         write(m_FileHan,&pos.m_Flags,MC_DBF_FLAGS_FIELDSIZE);
-        write(m_FileHan,&pos.m_KeyLen,1);
-        write(m_FileHan,&pos.m_ValLen,1);
+        mc_write(m_FileHan,pos.m_KeyLen,1);
+        mc_write(m_FileHan,pos.m_ValLen,1);
         write(m_FileHan,&ssKey[0],pos.m_KeyLen);
         write(m_FileHan,&ssValue[0],pos.m_ValLen);
         if(GetFileSize() < pos.NextOffset())
@@ -790,8 +817,8 @@ bool CDBFlat::Write(CDataStream& ssKey, CDataStream& ssValue, bool fOverwrite)
     pos.m_Offset=m_FileSize;
     SetFileOffset(pos.m_Offset);
     write(m_FileHan,&pos.m_Flags,MC_DBF_FLAGS_FIELDSIZE);
-    write(m_FileHan,&pos.m_KeyLen,key_size_bytes);
-    write(m_FileHan,&pos.m_ValLen,val_size_bytes);
+    mc_write(m_FileHan,pos.m_KeyLen,key_size_bytes);
+    mc_write(m_FileHan,pos.m_ValLen, val_size_bytes);
     if(pos.m_KeyLen)write(m_FileHan,&ssKey[0],pos.m_KeyLen);
     if(pos.m_ValLen)write(m_FileHan,&ssValue[0],pos.m_ValLen);
     
@@ -969,11 +996,11 @@ int CDBFlat::ReadAtCursor(void* pcursor, CDataStream& ssKey, CDataStream& ssValu
             }            
             lpPos->m_KeyLen=0;
             lpPos->m_ValLen=0;
-            if(read(m_FileHan,&(lpPos->m_KeyLen),key_size_bytes) != key_size_bytes)
+            if(mc_read(m_FileHan,&(lpPos->m_KeyLen),key_size_bytes) != key_size_bytes)
             {
                 return MC_DBW_CODE_DB_NOSERVER;  
             }
-            if(read(m_FileHan,&(lpPos->m_ValLen),val_size_bytes) != val_size_bytes)
+            if(mc_read(m_FileHan,&(lpPos->m_ValLen),val_size_bytes) != val_size_bytes)
             {
                 return MC_DBW_CODE_DB_NOSERVER;  
             }            
@@ -1221,4 +1248,4 @@ bool CDBFlat::Rewrite(CDBFlatEnv *lpEnv,const string& strFile, const char* pszSk
     lpEnv->RemoveDb(strFileCopy);
     
     return true;
-}
\ No newline at end of file
+}
diff --git a/src/wallet/dbflat.h b/src/wallet/dbflat.h
index 5590292..05e1fe8 100644
--- a/src/wallet/dbflat.h
+++ b/src/wallet/dbflat.h
@@ -153,6 +153,8 @@ public:
     
 };
 
+uint32_t mc_read(int _fd, unsigned int *_buf, size_t _nbyte );  // a wrap to support BE
+uint32_t mc_write(int _fd, unsigned int _buf, size_t _nbyte );  // a wrap to support BE
 
 
 #endif /* MULTICHAIN_DBFLAT_H */
diff --git a/src/wallet/wallet.cpp b/src/wallet/wallet.cpp
index fc7b235..ac35a4d 100644
--- a/src/wallet/wallet.cpp
+++ b/src/wallet/wallet.cpp
@@ -2733,7 +2733,7 @@ int CWallet::SelectMultiChainCombineCoinsMinConf(int nConfMine, int nConfTheirs,
             out_i=output.i;
             
             memcpy(buf_map,&hash,32);
-            mc_PutLE(buf_map+32,&out_i,4);
+            mc_PutLE(buf_map+32,out_i,4);
             int row=in_map->Seek(buf_map);
             if(row >= 0)
             {
@@ -2882,7 +2882,7 @@ bool CWallet::SelectMultiChainCoinsMinConf(const CAmount& nTargetValue, int nCon
             out_i=output.i;
             
             memcpy(buf_map,&hash,32);
-            mc_PutLE(buf_map+32,&out_i,4);
+            mc_PutLE(buf_map+32,out_i,4);
             int row=in_map->Seek(buf_map);
             if(row >= 0)
             {
@@ -3057,7 +3057,7 @@ bool CWallet::SelectMultiChainCoins(const CAmount& nTargetValue, vector<COutput>
                 out_i=out.i;
 
                 memcpy(buf_map,&hash,32);                                       // Retrieving coin index in the matrix
-                mc_PutLE(buf_map+32,&out_i,4);
+                mc_PutLE(buf_map+32,out_i,4);
                 int row=in_map->Seek(buf_map);
                 
                 if(row >= 0)
diff --git a/src/wallet/walletcoins.cpp b/src/wallet/walletcoins.cpp
index 5323245..3807016 100644
--- a/src/wallet/walletcoins.cpp
+++ b/src/wallet/walletcoins.cpp
@@ -552,7 +552,7 @@ int64_t mc_GetABCoinQuantity(void *ptr,int coin_id)
 
 void mc_SetABCoinQuantity(void *ptr,int coin_id,int64_t quantity)
 {
-    mc_PutLE((unsigned char*)ptr+MC_AST_ASSET_QUANTITY_OFFSET+coin_id*MC_AST_ASSET_QUANTITY_SIZE,&quantity,MC_AST_ASSET_QUANTITY_SIZE);        
+    mc_PutLE((unsigned char*)ptr+MC_AST_ASSET_QUANTITY_OFFSET+coin_id*MC_AST_ASSET_QUANTITY_SIZE,quantity,MC_AST_ASSET_QUANTITY_SIZE);
 }
 
 
@@ -719,8 +719,8 @@ bool InsertCoinIntoMatrix(int coin_id,
     
     
     memcpy(buf_map,&hash,32);                                                   // Updating txid/vout->coin id map
-    mc_PutLE(buf_map+32,&out_i,4);
-    mc_PutLE(buf_map+36,&coin_id,4);
+    mc_PutLE(buf_map+32,out_i,4);
+    mc_PutLE(buf_map+36,coin_id,4);
     in_map->Add(buf_map,buf_map+36);
 
     for(int i=0;i<tmp_amounts->GetCount();i++)                                  // Inserting asset amounts into the matrix
@@ -1206,7 +1206,7 @@ bool CalculateChangeAmounts(CWallet *lpWallet,
                             memset(buf,0,MC_AST_ASSET_FULLREF_BUF_SIZE+sizeof(int));
                             memcpy(buf,tmp_amounts->GetRow(i),MC_AST_ASSET_QUANTITY_OFFSET);
                             mc_SetABQuantity(buf,quantity);
-                            mc_PutLE(buf+MC_AST_ASSET_FULLREF_BUF_SIZE,&group_id,sizeof(int));
+                            mc_PutLE(buf+MC_AST_ASSET_FULLREF_BUF_SIZE,group_id,sizeof(int));
                             err=change_amounts->Add(buf);
                             if(err)
                             {
@@ -1373,7 +1373,7 @@ bool SelectCoinsToUse(const vector<COutPoint>* lpCoinsToUse,
         out_i=coin.n;
 
         memcpy(buf_map,&hash,32);
-        mc_PutLE(buf_map+32,&out_i,4);
+        mc_PutLE(buf_map+32,out_i,4);
         int row=in_map->Seek(buf_map);
         
         if(row<0)
@@ -1474,7 +1474,7 @@ bool SelectAssetCoins(CWallet *lpWallet,
             out_i=pcoin.second;
 
             memcpy(buf_map,&hash,32);
-            mc_PutLE(buf_map+32,&out_i,4);
+            mc_PutLE(buf_map+32,out_i,4);
             int row=in_map->Seek(buf_map);
             coin_id=mc_GetLE(in_map->GetRow(row)+36,4);
             quantity=1;
@@ -2264,7 +2264,7 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
     memset(in_row,-1,in_size);
     memset(in_row,0,MC_AST_ASSET_QUANTITY_OFFSET);
     type=0;
-    mc_PutLE(in_row+4,&type,4);
+    mc_PutLE(in_row+4,type,4);
     mc_SetABRefType(in_row,MC_AST_ASSET_REF_TYPE_SPECIAL);
     in_amounts->Add(in_row);
     
@@ -2272,7 +2272,7 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
     in_special_row[1]=in_amounts->GetCount();
     memset(in_row,0,in_size);
     type=0;
-    mc_PutLE(in_row+4,&type,4);
+    mc_PutLE(in_row+4,type,4);
     mc_SetABRefType(in_row,MC_AST_ASSET_REF_TYPE_SPECIAL);
     in_amounts->Add(in_row);
     
@@ -2280,7 +2280,7 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
     in_special_row[2]=in_amounts->GetCount();
     memset(in_row,0,in_size);
     type=0;
-    mc_PutLE(in_row+4,&type,4);
+    mc_PutLE(in_row+4,type,4);
     mc_SetABRefType(in_row,MC_AST_ASSET_REF_TYPE_SPECIAL);
     in_amounts->Add(in_row);
     
@@ -2288,7 +2288,7 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
     in_special_row[3]=in_amounts->GetCount();
     memset(in_row,0,in_size);
     type=MC_PTP_SEND;
-    mc_PutLE(in_row+4,&type,4);
+    mc_PutLE(in_row+4,type,4);
     mc_SetABRefType(in_row,MC_AST_ASSET_REF_TYPE_SPECIAL);
     in_amounts->Add(in_row);
     
@@ -2297,7 +2297,7 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
     memset(in_row,0,in_size);
     type=MC_PTP_SEND;
     mc_SetABRefType(in_row,MC_AST_ASSET_REF_TYPE_SPECIAL);
-    mc_PutLE(in_row+4,&type,4);
+    mc_PutLE(in_row+4,type,4);
     in_amounts->Add(in_row);
     
                                                                                 // Issue row, coin value if input has issue permission, 0 otherwise
@@ -2306,7 +2306,7 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
         in_special_row[5]=in_amounts->GetCount();
         memset(in_row,0,in_size);
         type=MC_PTP_ISSUE | MC_PTP_SEND;
-        mc_PutLE(in_row+4,&type,4);
+        mc_PutLE(in_row+4,type,4);
         mc_SetABRefType(in_row,MC_AST_ASSET_REF_TYPE_SPECIAL);
         in_amounts->Add(in_row);
     }
@@ -2317,7 +2317,7 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
         in_special_row[6]=in_amounts->GetCount();
         memset(in_row,0,in_size);
         type=MC_PTP_ADMIN | MC_PTP_SEND;
-        mc_PutLE(in_row+4,&type,4);
+        mc_PutLE(in_row+4,type,4);
         mc_SetABRefType(in_row,MC_AST_ASSET_REF_TYPE_SPECIAL);
         in_amounts->Add(in_row);
     }
@@ -2328,7 +2328,7 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
         in_special_row[7]=in_amounts->GetCount();
         memset(in_row,0,in_size);
         type=MC_PTP_ACTIVATE | MC_PTP_SEND;
-        mc_PutLE(in_row+4,&type,4);
+        mc_PutLE(in_row+4,type,4);
         mc_SetABRefType(in_row,MC_AST_ASSET_REF_TYPE_SPECIAL);
         in_amounts->Add(in_row);
     }
@@ -2339,7 +2339,7 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
         in_special_row[8]=in_amounts->GetCount();
         memset(in_row,0,in_size);
         type=MC_PTP_WRITE | MC_PTP_SEND;
-        mc_PutLE(in_row+4,&type,4);
+        mc_PutLE(in_row+4,type,4);
         mc_SetABRefType(in_row,MC_AST_ASSET_REF_TYPE_SPECIAL);
         in_amounts->Add(in_row);
     }
@@ -2350,7 +2350,7 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
         in_special_row[9]=in_amounts->GetCount();
         memset(in_row,0,in_size);
         type=MC_PTP_CREATE | MC_PTP_SEND;
-        mc_PutLE(in_row+4,&type,4);
+        mc_PutLE(in_row+4,type,4);
         mc_SetABRefType(in_row,MC_AST_ASSET_REF_TYPE_SPECIAL);
         in_amounts->Add(in_row);
     }
-- 
1.8.3.1

