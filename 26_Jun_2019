From 9636cc3dac396f956b99ef12546b7a21f3db06d7 Mon Sep 17 00:00:00 2001
From: Krishna Harsha Voora <krishvoor@in.ibm.com>
Date: Tue, 25 Jun 2019 21:29:50 -0400
Subject: [PATCH] Applying BE Changes to Bitcoin & Multichain for s390x arch.

        1) Changes specific to s390x added to v8_data_lib.py & to build v8
        2) Changes specific to s390x added for 2.0-dev
        3) Updated wallet/dbflat.cpp & wallet/dbflat.h  accordingly to work on s390x
        4) Updated src/chainparams/params.cpp, so params.dat remains intact on s390x after daemon start
        5) Updated src/miner/miner.cpp, so Mining can happen seamlessly
        6) Updated src/utils/utilwrapper.cpp, src/miner/miner.cpp, to solve IP[Byte-Swap] on BE]
	7) v8 related object files were built using GSM's assembler
	8) Moved to 2.0-dev (v2.0.2)
	9) Changes specific to allow Z-Slave node to connect to X-Master Node is added (Testing WIP)

Signed-off-by: Krishna Harsha Voora <krishvoor@in.ibm.com>
---
 configure.ac                      | 13 ++++++---
 src/chainparams/params.cpp        | 58 +++++++++++++++++++++++----------------
 src/compat/byteswap.h             | 47 +++++++++++++++++++++++++++++++
 src/core/init.cpp                 |  1 +
 src/core/main.cpp                 |  4 ++-
 src/entities/asset.cpp            | 34 +++++++++++------------
 src/miner/miner.cpp               | 38 +++++++++++++++----------
 src/net/net.cpp                   |  7 +++++
 src/primitives/block.cpp          | 25 +++++++++++++++--
 src/protocol/handshake.cpp        |  1 +
 src/protocol/multichainscript.cpp | 26 +++++++++---------
 src/protocol/multichaintx.cpp     |  4 +--
 src/protocol/relay.cpp            |  2 +-
 src/rpc/rpcassets.cpp             | 29 +++++++++++---------
 src/rpc/rpcdebug.cpp              |  2 +-
 src/rpc/rpcutils.cpp              |  4 +--
 src/structs/hash.h                |  3 +-
 src/structs/uint256.cpp           | 39 +++++++++++++++++++++++++-
 src/structs/uint256.h             |  3 +-
 src/utils/declare.h               |  2 +-
 src/utils/serialize.h             | 41 +++++++++++++--------------
 src/utils/tools.cpp               |  2 +-
 src/utils/utility.cpp             | 11 ++++++--
 src/utils/utilparse.cpp           | 12 ++++----
 src/utils/utilwrapper.cpp         |  8 ++++--
 src/v8/v8engine.cpp               | 10 +++----
 src/wallet/dbflat.cpp             | 47 ++++++++++++++++++++++++-------
 src/wallet/wallet.cpp             |  6 ++--
 src/wallet/walletcoins.cpp        | 32 ++++++++++-----------
 29 files changed, 347 insertions(+), 164 deletions(-)
 create mode 100644 src/compat/byteswap.h

diff --git a/configure.ac b/configure.ac
index 9f5ebec..5f42a00 100644
--- a/configure.ac
+++ b/configure.ac
@@ -363,8 +363,8 @@ if test x$use_lcov = xyes; then
     [AC_MSG_ERROR("lcov testing requested but --coverage flag does not work")])
 fi
 
-dnl Require little endian
-AC_C_BIGENDIAN([AC_MSG_ERROR("Big Endian not supported")])
+dnl Check for endianness
+AC_C_BIGENDIAN
 
 dnl Check for pthread compile/link requirements
 AX_PTHREAD
@@ -451,17 +451,22 @@ if test x$TARGET_OS = xdarwin; then
   AX_CHECK_LINK_FLAG([[-Wl,-dead_strip]], [LDFLAGS="$LDFLAGS -Wl,-dead_strip"])
 fi
 
-AC_CHECK_HEADERS([endian.h stdio.h stdlib.h unistd.h strings.h sys/types.h sys/stat.h sys/select.h sys/prctl.h])
+AC_CHECK_HEADERS([endian.h byteswap.h stdio.h stdlib.h unistd.h strings.h sys/types.h sys/stat.h sys/select.h sys/prctl.h])
 AC_SEARCH_LIBS([getaddrinfo_a], [anl], [AC_DEFINE(HAVE_GETADDRINFO_A, 1, [Define this symbol if you have getaddrinfo_a])])
 AC_SEARCH_LIBS([inet_pton], [nsl resolv], [AC_DEFINE(HAVE_INET_PTON, 1, [Define this symbol if you have inet_pton])])
 
 AC_CHECK_DECLS([strnlen])
 
-AC_CHECK_DECLS([le32toh, le64toh, htole32, htole64, be32toh, be64toh, htobe32, htobe64],,,
+AC_CHECK_DECLS([le16toh, le32toh, le64toh, htole16, htole32, htole64, be16toh, be32toh, be64toh, htobe16, htobe32, htobe64],,,
 		[#if HAVE_ENDIAN_H
                  #include <endian.h>
                  #endif])
 
+AC_CHECK_DECLS([bswap_16, bswap_32, bswap_64],,,
+		[#if HAVE_BYTESWAP_H
+                 #include <byteswap.h>
+                 #endif])
+
 dnl Check for MSG_NOSIGNAL
 AC_MSG_CHECKING(for MSG_NOSIGNAL)
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/socket.h>]],
diff --git a/src/chainparams/params.cpp b/src/chainparams/params.cpp
index 6647a9b..cf2a575 100644
--- a/src/chainparams/params.cpp
+++ b/src/chainparams/params.cpp
@@ -342,7 +342,7 @@ int mc_MultichainParams::SetParam(const char *param,const char* value,int size)
         memcpy(m_lpData+offset+MC_PRM_PARAM_SIZE_BYTES,value,size);
     }
     
-    mc_PutLE(m_lpData+offset,&size,MC_PRM_PARAM_SIZE_BYTES);
+    mc_PutLE(m_lpData+offset,size,MC_PRM_PARAM_SIZE_BYTES);
     offset+=MC_PRM_PARAM_SIZE_BYTES;
     m_lpCoord[2 * index + 0]=offset;
     m_lpCoord[2 * index + 1]=size;
@@ -384,7 +384,7 @@ int mc_MultichainParams::SetParam(const char *param,int64_t value)
             return MC_ERR_INTERNAL_ERROR;
     }
 
-    mc_PutLE(buf,&value,size);
+    mc_PutLE(buf,value,size);
     return SetParam(param,buf,size);
 }
 
@@ -511,17 +511,17 @@ int mc_MultichainParams::Create(const char* name,int version)
                             case MC_PRM_INT32:
                             case MC_PRM_UINT32:
                                 size=4;
-                                mc_PutLE(ptrData,&(param->m_DefaultIntegerValue),4);
+                                mc_PutLE(ptrData,(param->m_DefaultIntegerValue),4);
                                 break;
                             case MC_PRM_INT64:
                                 size=8;
-                                mc_PutLE(ptrData,&(param->m_DefaultIntegerValue),8);
+                                mc_PutLE(ptrData,(param->m_DefaultIntegerValue),8);
                                 if(strcmp(param->m_Name,"maxstdelementsize") == 0)
                                 {
                                     if(version<20003)
                                     {
                                         override_int64=8192;
-                                        mc_PutLE(ptrData,&override_int64,8);
+                                        mc_PutLE(ptrData,override_int64,8);
                                     }
                                 }                                   
                                 break;
@@ -538,18 +538,18 @@ int mc_MultichainParams::Create(const char* name,int version)
                             network_port=mc_RandomInRange(0,sizeof(FreePortRangesOver50)/sizeof(uint32_t)-1);
                             network_port=FreePortRangesOver50[network_port];
                             network_port+=1+2*mc_RandomInRange(0,24);
-                            mc_PutLE(ptrData,&network_port,4);
+                            mc_PutLE(ptrData,network_port,4);
                         }
                         if(strcmp(param->m_Name,"defaultrpcport") == 0)
                         {
                             size=4;
                             rpc_port=network_port-1;
-                            mc_PutLE(ptrData,&rpc_port,4);
+                            mc_PutLE(ptrData,rpc_port,4);
                         }
                         if(strcmp(param->m_Name,"protocolversion") == 0)
                         {
                             size=4;
-                            mc_PutLE(ptrData,&version,4);
+                            mc_PutLE(ptrData,version,4);
                         }
                         if(strcmp(param->m_Name,"chainname") == 0)
                         {
@@ -608,7 +608,7 @@ int mc_MultichainParams::Create(const char* name,int version)
                         break;
                 }
 
-                mc_PutLE(m_lpData+offset,&size,MC_PRM_PARAM_SIZE_BYTES);
+                mc_PutLE(m_lpData+offset,size,MC_PRM_PARAM_SIZE_BYTES);
                 offset+=MC_PRM_PARAM_SIZE_BYTES;
                 m_lpCoord[2 * i + 0]=offset;
                 m_lpCoord[2 * i + 1]=size;
@@ -807,18 +807,22 @@ int mc_MultichainParams::Read(const char* name,int argc, char* argv[],int create
                     if((MultichainParamArray+i)->m_Type & MC_PRM_DECIMAL)
                     {
                         double d=atof(ptr);
+                        int32_t tmp ; 
                         if(d >= 0)
                         {
-                            *(int32_t*)ptrData=(int32_t)(d*MC_PRM_DECIMAL_GRANULARITY+ParamAccuracy());                            
+                            tmp=(int32_t)(d*MC_PRM_DECIMAL_GRANULARITY+ParamAccuracy());                            
+                            mc_PutLE(ptrData, tmp, 4); 
                         }
                         else
                         {
-                            *(int32_t*)ptrData=-(int32_t)(-d*MC_PRM_DECIMAL_GRANULARITY+ParamAccuracy());                                                        
+                            tmp=(int32_t)(-d*MC_PRM_DECIMAL_GRANULARITY+ParamAccuracy());
+                            mc_PutLE(ptrData, tmp, 4);
                         }
                     }
                     else
                     {
-                        *(int32_t*)ptrData=(int32_t)atol(ptr);
+                            int32_t tmp =(int32_t)atol(ptr);                       
+                            mc_PutLE(ptrData, tmp, 4);
                     }
                     break;
                 case MC_PRM_UINT32:
@@ -838,11 +842,13 @@ int mc_MultichainParams::Read(const char* name,int argc, char* argv[],int create
                     }
                     if((MultichainParamArray+i)->m_Type & MC_PRM_DECIMAL)
                     {
-                        *(int32_t*)ptrData=(int32_t)(atof(ptr)*MC_PRM_DECIMAL_GRANULARITY+ParamAccuracy());
+                        int32_t tmp=(int32_t)(atof(ptr)*MC_PRM_DECIMAL_GRANULARITY+ParamAccuracy());
+                        mc_PutLE(ptrData, tmp, 4); 
                     }
                     else
                     {
-                        *(int32_t*)ptrData=(int32_t)atol(ptr);
+                        int32_t tmp =(int32_t)atol(ptr);
+                        mc_PutLE(ptrData, tmp, 4); 
                     }
                     if(ptr[0]=='-')
                     {
@@ -864,16 +870,20 @@ int mc_MultichainParams::Read(const char* name,int argc, char* argv[],int create
                             return MC_ERR_INVALID_PARAMETER_VALUE;                                                
                         }
                     }
-                    size=8;
-                    *(int64_t*)ptrData=(int64_t)atoll(ptr);
-                    break;
+                    { size=8;
+                      int64_t tmp1 = (int64_t) atoll(ptr); 
+                      mc_PutLE(ptrData, tmp1, 8);
+                      break;
+                    }
                 case MC_PRM_DOUBLE:
                     size=8;
                     *((double*)ptrData)=atof(ptr);
+                    double tmp_2 =(float)atof(ptr);
+                    mc_PutLE(ptrData, tmp_2, 8);
                     break;
             }            
             
-            mc_PutLE(m_lpData+offset,&size,MC_PRM_PARAM_SIZE_BYTES);
+            mc_PutLE(m_lpData+offset,size,MC_PRM_PARAM_SIZE_BYTES);
             offset+=MC_PRM_PARAM_SIZE_BYTES;
             m_lpCoord[2 * i + 0]=offset;
             m_lpCoord[2 * i + 1]=size;
@@ -901,7 +911,7 @@ int mc_MultichainParams::Read(const char* name,int argc, char* argv[],int create
                 {
                     memcpy(ptrData,ptr,size);
                 }            
-                mc_PutLE(m_lpData+offset,&size,MC_PRM_PARAM_SIZE_BYTES);
+                mc_PutLE(m_lpData+offset,size,MC_PRM_PARAM_SIZE_BYTES);
                 offset+=MC_PRM_PARAM_SIZE_BYTES;
                 m_lpCoord[2 * i + 0]=offset;
                 m_lpCoord[2 * i + 1]=size;
@@ -975,7 +985,7 @@ int mc_MultichainParams::Set(const char *name,const char *source,int source_size
                     {
                         memcpy(ptrData,source+j,size);
                     }
-                    mc_PutLE(m_lpData+offset,&size,MC_PRM_PARAM_SIZE_BYTES);
+                    mc_PutLE(m_lpData+offset,size,MC_PRM_PARAM_SIZE_BYTES);
                     offset+=MC_PRM_PARAM_SIZE_BYTES;
                     m_lpCoord[2 * i + 0]=offset;
                     m_lpCoord[2 * i + 1]=size;
@@ -1040,7 +1050,7 @@ int mc_MultichainParams::Clone(const char* name, mc_MultichainParams* source)
             {
                 memcpy(ptrData,ptr,size);
             }
-            mc_PutLE(m_lpData+offset,&size,MC_PRM_PARAM_SIZE_BYTES);
+            mc_PutLE(m_lpData+offset,size,MC_PRM_PARAM_SIZE_BYTES);
             offset+=MC_PRM_PARAM_SIZE_BYTES;
             m_lpCoord[2 * i + 0]=offset;
             m_lpCoord[2 * i + 1]=size;
@@ -1210,7 +1220,7 @@ int mc_MultichainParams::Validate()
                                         break;
                                     case MC_PRM_INT64:
                                         size=8;
-                                        mc_PutLE(ptrData,&((m_lpParams+i)->m_DefaultIntegerValue),8);
+                                        mc_PutLE(ptrData,((m_lpParams+i)->m_DefaultIntegerValue),8);
                                         break;
                                     case MC_PRM_DOUBLE:
                                         size=8;
@@ -1218,11 +1228,11 @@ int mc_MultichainParams::Validate()
                                         break;
                                     default:
                                         size=4;
-                                        mc_PutLE(ptrData,&((m_lpParams+i)->m_DefaultIntegerValue),4);
+                                        mc_PutLE(ptrData,((m_lpParams+i)->m_DefaultIntegerValue),4);
                                         break;
                                 }
                                 
-                                mc_PutLE(m_lpData+offset,&size,MC_PRM_PARAM_SIZE_BYTES);
+                                mc_PutLE(m_lpData+offset,size,MC_PRM_PARAM_SIZE_BYTES);
                                 offset+=MC_PRM_PARAM_SIZE_BYTES;
                                 m_lpCoord[2 * i + 0]=offset;
                                 m_lpCoord[2 * i + 1]=size;
diff --git a/src/compat/byteswap.h b/src/compat/byteswap.h
new file mode 100644
index 0000000..899220b
--- /dev/null
+++ b/src/compat/byteswap.h
@@ -0,0 +1,47 @@
+// Copyright (c) 2014 The Bitcoin developers
+// Distributed under the MIT software license, see the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#ifndef BITCOIN_COMPAT_BYTESWAP_H
+#define BITCOIN_COMPAT_BYTESWAP_H
+
+#if defined(HAVE_CONFIG_H)
+#include "config/bitcoin-config.h"
+#endif
+
+#include <stdint.h>
+
+#if defined(HAVE_BYTESWAP_H)
+#include <byteswap.h>
+#endif
+
+#if HAVE_DECL_BSWAP_16 == 0
+inline uint16_t bswap_16(uint16_t x)
+{
+    return (x >> 8) | ((x & 0x00ff) << 8);
+}
+#endif // HAVE_DECL_BSWAP16
+
+#if HAVE_DECL_BSWAP_32 == 0
+inline uint32_t bswap_32(uint32_t x)
+{
+    return (((x & 0xff000000U) >> 24) | ((x & 0x00ff0000U) >>  8) |
+            ((x & 0x0000ff00U) <<  8) | ((x & 0x000000ffU) << 24));
+}
+#endif // HAVE_DECL_BSWAP32
+
+#if HAVE_DECL_BSWAP_64 == 0
+inline uint64_t bswap_64(uint64_t x)
+{
+     return (((x & 0xff00000000000000ull) >> 56)
+          | ((x & 0x00ff000000000000ull) >> 40)
+          | ((x & 0x0000ff0000000000ull) >> 24)
+          | ((x & 0x000000ff00000000ull) >> 8)
+          | ((x & 0x00000000ff000000ull) << 8)
+          | ((x & 0x0000000000ff0000ull) << 24)
+          | ((x & 0x000000000000ff00ull) << 40)
+          | ((x & 0x00000000000000ffull) << 56));
+}
+#endif // HAVE_DECL_BSWAP64
+
+#endif // BITCOIN_COMPAT_BYTESWAP_H
diff --git a/src/core/init.cpp b/src/core/init.cpp
index febb031..ee17f5e 100644
--- a/src/core/init.cpp
+++ b/src/core/init.cpp
@@ -1317,6 +1317,7 @@ bool AppInit2(boost::thread_group& threadGroup,int OutputPipe)
             }            
 */
             
+    LogPrintf("++++++++ network_status=%s\n", mc_gState->m_NetworkState);        
             if(mc_QuerySeed(seedThreadGroup,seed_node))
             {
                 if((mc_gState->m_NetworkState == MC_NTS_SEED_READY) || (mc_gState->m_NetworkState == MC_NTS_SEED_NO_PARAMS) )
diff --git a/src/core/main.cpp b/src/core/main.cpp
index c2ef86a..e485209 100644
--- a/src/core/main.cpp
+++ b/src/core/main.cpp
@@ -5670,6 +5670,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,
 /* MCHN END */
 
 //    RandAddSeedPerfmon();
+  LogPrintf("++++ start ProcessMessage\n");
     if(fDebug)LogPrint("net", "received: %s (%u bytes) peer=%d\n", SanitizeString(strCommand), vRecv.size(), pfrom->id);
     if (mapArgs.count("-dropmessagestest") && (atoi(mapArgs["-dropmessagestest"]) > 0) && (GetRand(atoi(mapArgs["-dropmessagestest"])) == 0) )
     {
@@ -5744,6 +5745,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,
 
         // Change version
 /* MCHN START */
+  LogPrintf("++++ start shakehand\n");
         pfrom->nVersionNonceReceived=nNonce; 
         pfrom->fVerackackReceived=false;
         if(mc_gState->m_NetworkParams->IsProtocolMultichain())
@@ -6797,7 +6799,6 @@ bool ProcessMessages(CNode* pfrom)
 {
     //if (fDebug)
     //    LogPrintf("ProcessMessages(%u messages)\n", pfrom->vRecvMsg.size());
-
     //
     // Message format
     //  (4) message start
@@ -6806,6 +6807,7 @@ bool ProcessMessages(CNode* pfrom)
     //  (4) checksum
     //  (x) data
     //
+                    LogPrintf("+++++ 0 start ProcessMessages\n");            
     bool fOk = true;
 
     if (!pfrom->vRecvGetData.empty())
diff --git a/src/entities/asset.cpp b/src/entities/asset.cpp
index dccbd59..59c90e2 100644
--- a/src/entities/asset.cpp
+++ b/src/entities/asset.cpp
@@ -2,6 +2,7 @@
 // MultiChain code distributed under the GPLv3 license, see COPYING file.
 
 #include "multichain/multichain.h"
+#include <compat/byteswap.h>
 
 #define MC_AST_ASSET_REF_TYPE_OFFSET        32
 #define MC_AST_ASSET_REF_TYPE_SIZE           4
@@ -589,8 +590,8 @@ void mc_EntityDetails::Set(mc_EntityLedgerRow* row)
     
     if(offset)
     {
-        mc_PutLE(m_Ref,&block,4);
-        mc_PutLE(m_Ref+4,&offset,4);
+        mc_PutLE(m_Ref,block,4);
+        mc_PutLE(m_Ref+4,offset,4);
         for(i=0;i<MC_ENT_REF_PREFIX_SIZE;i++)
         {
             m_Ref[8+i]=*(row->m_Key+MC_ENT_KEY_SIZE-1-i);
@@ -615,7 +616,7 @@ void mc_EntityDetails::Set(mc_EntityLedgerRow* row)
             m_Permissions |= MC_PTP_ADMIN | MC_PTP_ACTIVATE | MC_PTP_WRITE;
             if(mc_gState->m_Features->ReadPermissions())
             {
-                m_Permissions |= MC_PTP_READ;                
+                m_Permissions |= MC_PTP_READ;
             }
             break;
         default:
@@ -624,7 +625,7 @@ void mc_EntityDetails::Set(mc_EntityLedgerRow* row)
                 m_Permissions = MC_PTP_WRITE | MC_PTP_ACTIVATE;
                 if(mc_gState->m_Features->ReadPermissions())
                 {
-                    m_Permissions |= MC_PTP_READ;                
+                    m_Permissions |= MC_PTP_READ;
                 }
             }
             break;            
@@ -651,7 +652,7 @@ void mc_EntityDetails::Set(mc_EntityLedgerRow* row)
             }
         }
         if(value_offset < m_LedgerRow.m_ScriptSize)
-        {            
+        {
             if(value_size > MC_ENT_MAX_NAME_SIZE)
             {
                 value_size=MC_ENT_MAX_NAME_SIZE;
@@ -660,16 +661,16 @@ void mc_EntityDetails::Set(mc_EntityLedgerRow* row)
             }
             else
             {
-                memcpy(m_Name,m_LedgerRow.m_Script+value_offset,value_size);                
+                memcpy(m_Name,m_LedgerRow.m_Script+value_offset,value_size);
             }
             mc_StringLowerCase(m_Name,value_size);
             m_Flags |= MC_ENT_FLAG_NAME_IS_SET;
         }
-        
+
         value_offset=mc_FindSpecialParamInDetailsScript(m_LedgerRow.m_Script,m_LedgerRow.m_ScriptSize,MC_ENT_SPRM_PERMISSIONS,&value_size);
         if(value_offset <= m_LedgerRow.m_ScriptSize)
         {
-            if( (value_offset != m_LedgerRow.m_ScriptSize) || (mc_gState->m_Features->FixedLegacyPermissionRestrictionFlag() == 0)) 
+            if( (value_offset != m_LedgerRow.m_ScriptSize) || (mc_gState->m_Features->FixedLegacyPermissionRestrictionFlag() == 0))
             {
                 m_Permissions |= MC_PTP_SPECIFIED;
                 if((value_size>0) && (value_size<=4))
@@ -679,7 +680,7 @@ void mc_EntityDetails::Set(mc_EntityLedgerRow* row)
                 }
             }
         }
-                            
+
         value_offset=mc_FindSpecialParamInDetailsScript(m_LedgerRow.m_Script,m_LedgerRow.m_ScriptSize,MC_ENT_SPRM_RESTRICTIONS,&value_size);
         if(value_offset <= m_LedgerRow.m_ScriptSize)
         {
@@ -691,7 +692,6 @@ void mc_EntityDetails::Set(mc_EntityLedgerRow* row)
                 }
             }
         }
-        
     }
     
     mc_ZeroABRaw(m_FullRef);
@@ -937,6 +937,9 @@ int mc_AssetDB::InsertAsset(const void* txid, int offset, int asset_type, uint64
 
     if(add_param)
     {
+	#if WORDS_BIGENDIAN == 1
+		multiple = bswap_32(multiple);  // convert to LE format
+	#endif
         lpDetails->SetSpecialParamValue(MC_ENT_SPRM_ASSET_MULTIPLE,(unsigned char*)&multiple,sizeof(multiple));
     }
     
@@ -1825,12 +1828,10 @@ const unsigned char* mc_EntityDetails::GetScript()
 {
     return m_LedgerRow.m_Script;
 }
-
 uint32_t mc_EntityDetails::GetScriptSize()
 {
     return m_LedgerRow.m_ScriptSize;
 }
-
 int mc_EntityDetails::GetAssetMultiple()
 {
     int multiple;
@@ -1940,7 +1941,6 @@ int mc_EntityDetails::AnyoneCanWrite()
     }
     return 0;
 }
-
 int mc_EntityDetails::AnyoneCanRead()
 {
     if(m_LedgerRow.m_EntityType != MC_ENT_TYPE_STREAM)
@@ -1957,7 +1957,7 @@ int mc_EntityDetails::AnyoneCanRead()
             }
         }
     }
-    
+
     return 1;
 }
 
@@ -2398,7 +2398,7 @@ uint32_t mc_GetABScriptType(void *ptr)
 
 void mc_SetABScriptType(void *ptr,uint32_t type)
 {
-    mc_PutLE((unsigned char*)ptr+MC_AST_ASSET_SCRIPT_TYPE_OFFSET,&type,MC_AST_ASSET_SCRIPT_TYPE_SIZE);
+    mc_PutLE((unsigned char*)ptr+MC_AST_ASSET_SCRIPT_TYPE_OFFSET,type,MC_AST_ASSET_SCRIPT_TYPE_SIZE);
 }
 
 uint32_t mc_GetABRefType(void *ptr)
@@ -2408,7 +2408,7 @@ uint32_t mc_GetABRefType(void *ptr)
 
 void mc_SetABRefType(void *ptr,uint32_t type)
 {
-    mc_PutLE((unsigned char*)ptr+MC_AST_ASSET_REF_TYPE_OFFSET,&type,MC_AST_ASSET_REF_TYPE_SIZE);    
+    mc_PutLE((unsigned char*)ptr+MC_AST_ASSET_REF_TYPE_OFFSET,type,MC_AST_ASSET_REF_TYPE_SIZE);
 }
 
 int64_t mc_GetABQuantity(void *ptr)
@@ -2418,7 +2418,7 @@ int64_t mc_GetABQuantity(void *ptr)
 
 void mc_SetABQuantity(void *ptr,int64_t quantity)
 {
-    mc_PutLE((unsigned char*)ptr+MC_AST_ASSET_QUANTITY_OFFSET,&quantity,MC_AST_ASSET_QUANTITY_SIZE);        
+    mc_PutLE((unsigned char*)ptr+MC_AST_ASSET_QUANTITY_OFFSET,quantity,MC_AST_ASSET_QUANTITY_SIZE);
 }
 
 unsigned char* mc_GetABRef(void *ptr)
diff --git a/src/miner/miner.cpp b/src/miner/miner.cpp
index e412424..6b202cd 100644
--- a/src/miner/miner.cpp
+++ b/src/miner/miner.cpp
@@ -130,9 +130,9 @@ bool CreateBlockSignature(CBlock *block,uint32_t hash_type,CWallet *pwallet,uint
     int coinbase_tx,op_return_output;
     uint256 hash_to_verify;
     vector<uint256> cachedMerkleBranch;
-    
+
     cachedMerkleBranch.clear();
-    
+
     std::vector<unsigned char> vchSigOut;
     std::vector<unsigned char> vchPubKey;
     
@@ -766,6 +766,11 @@ int64_t nHPSTimerStart = 0;
 //
 bool static ScanHash(CBlock *pblock, uint32_t& nNonce, uint256 *phash,uint16_t success_and_mask,CWallet *pwallet)
 {
+    uint256 cachedMerkleRoot=0;
+#if WORDS_BIGENDIAN == 1
+	uint256 phash_tmp;
+	CBlock pblock_tmp =  *pblock;
+#else
     // Write the first 76 bytes of the block header to a double-SHA256 state.
     CHash256 hasher;
     CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);
@@ -773,9 +778,10 @@ bool static ScanHash(CBlock *pblock, uint32_t& nNonce, uint256 *phash,uint16_t s
 //    ss << *pblock;
     assert(ss.size() == 80);
     hasher.Write((unsigned char*)&ss[0], 76);
-    uint256 cachedMerkleRoot=0;    
-    
-    while (true) {
+    //uint256 cachedMerkleRoot=0;
+
+#endif
+ while (true) {
         nNonce++;
 
         if(Params().DisallowUnsignedBlockNonce())
@@ -786,10 +792,16 @@ bool static ScanHash(CBlock *pblock, uint32_t& nNonce, uint256 *phash,uint16_t s
         }
         else
         {
+#if WORDS_BIGENDIAN == 1
+           pblock_tmp.nNonce =nNonce;
+           phash_tmp = pblock_tmp.GetHash();
+           *phash = phash_tmp;
+#else
             // Write the last 4 bytes of the block header (the nonce) to a copy of
             // the double-SHA256 state, and compute the result.
             CHash256(hasher).Write((unsigned char*)&nNonce, 4).Finalize((unsigned char*)phash);
-        }
+#endif
+         }
 
         // Return the nonce if the hash has at least some zero bits,
         // caller will check if it has enough to reach the target
@@ -801,9 +813,9 @@ bool static ScanHash(CBlock *pblock, uint32_t& nNonce, uint256 *phash,uint16_t s
         {
             if(Params().DisallowUnsignedBlockNonce())
             {
-                pblock->hashMerkleRoot=pblock->BuildMerkleTree();                   
+                pblock->hashMerkleRoot=pblock->BuildMerkleTree();
             }
-            return true;            
+            return true;
         }
         
         // If nothing found after trying for a while, return -1
@@ -812,7 +824,7 @@ bool static ScanHash(CBlock *pblock, uint32_t& nNonce, uint256 *phash,uint16_t s
 //        if ((nNonce & 0xff) == 0)
             if(Params().DisallowUnsignedBlockNonce())
             {
-                pblock->hashMerkleRoot=pblock->BuildMerkleTree();                   
+                pblock->hashMerkleRoot=pblock->BuildMerkleTree();
             }
             return false;
         }
@@ -987,7 +999,6 @@ int GetMaxActiveMinersCount()
         return 1024;
     }
 }
-
 double GetMinerAndExpectedMiningStartTime(CWallet *pwallet,CPubKey *lpkMiner,set <CTxDestination> *lpsMinerPool,double *lpdMiningStartTime,double *lpdActiveMiners,uint256 *lphLastBlockHash,int *lpnMemPoolSize,double wAvBlockTime)
 {
     int nMinerPoolSizeMin=4;
@@ -1138,7 +1149,7 @@ double GetMinerAndExpectedMiningStartTime(CWallet *pwallet,CPubKey *lpkMiner,set
         
         *lpdMiningStartTime=dExpectedTime;
     }
-       
+    
     fInMinerPool=false;
     if(mc_gState->m_NetworkParams->IsProtocolMultichain())
     {
@@ -1203,11 +1214,10 @@ double GetMinerAndExpectedMiningStartTime(CWallet *pwallet,CPubKey *lpkMiner,set
             *lpdActiveMiners=(double)GetMaxActiveMinersCount() - nMinerPoolSize;            
             *lpdActiveMiners/=dActualMinerDrift;
         }
-
         if(fInMinerPool)
         {
             *lpdMiningStartTime += mc_RandomDouble() * dSpread;
-            *lpdMiningStartTime -= dSpread / (nMinerPoolSize + 1);   
+            *lpdMiningStartTime -= dSpread / (nMinerPoolSize + 1);
             *lpdMiningStartTime -= dAverageCreateBlockTimeShift;
         }
         else
@@ -1452,7 +1462,6 @@ void static BitcoinMiner(CWallet *pwallet)
             {
                 nMemPoolSize=1;
             }
-            
             double wAvTimePerBlock=0;
             for(int w=0;w<wSize;w++)
             {
@@ -1664,6 +1673,7 @@ void static BitcoinMiner(CWallet *pwallet)
                 {
 /* MCHN START */                    
                     CreateBlockSignature(pblock,BLOCKSIGHASH_NO_SIGNATURE_AND_NONCE,pwallet,NULL);
+
 /* MCHN END */                    
                 }
                 if (Params().AllowMinDifficultyBlocks())
diff --git a/src/net/net.cpp b/src/net/net.cpp
index f312146..be906d0 100644
--- a/src/net/net.cpp
+++ b/src/net/net.cpp
@@ -1340,6 +1340,8 @@ void ThreadOpenConnections()
 
 /* MCHN END */    
     
+ int aa=1;
+        LogPrintf("+++++++++++ net  count:%d, network_status:%s\n", aa++, mc_gState->m_NetworkState);
     // Initiate network connections
     int64_t nStart = GetTime();
     while (true)
@@ -1368,6 +1370,7 @@ void ThreadOpenConnections()
         //
         CAddress addrConnect;
 
+        LogPrintf("+++++++++++ net  count:%d, network_status:%s\n", aa++, mc_gState->m_NetworkState);
         
         // Only connect out to one peer per network group (/16 for IPv4).
         // Do this here so we don't have to critsect vNodes inside mapAddresses critsect.
@@ -1666,6 +1669,7 @@ bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOu
 
 void ThreadMessageHandler()
 {
+        LogPrintf("++++++++++ ThreadMessageHandler\n");
     SetThreadPriority(THREAD_PRIORITY_BELOW_NORMAL);
     while (true)
     {
@@ -1678,6 +1682,7 @@ void ThreadMessageHandler()
             }
         }
 
+        LogPrintf("++++++++++ Poll the connected nodes for messages \n");
         // Poll the connected nodes for messages
         CNode* pnodeTrickle = NULL;
         if (!vNodesCopy.empty())
@@ -1690,6 +1695,8 @@ void ThreadMessageHandler()
             if (pnode->fDisconnect)
                 continue;
 
+        LogPrintf("++++++++++ Receive messagess \n");
+
             // Receive messages
             {
                 TRY_LOCK(pnode->cs_vRecvMsg, lockRecv);
diff --git a/src/primitives/block.cpp b/src/primitives/block.cpp
index 3ba859c..53f7bed 100644
--- a/src/primitives/block.cpp
+++ b/src/primitives/block.cpp
@@ -10,9 +10,30 @@
 #include "utils/tinyformat.h"
 #include "utils/utilstrencodings.h"
 
-uint256 CBlockHeader::GetHash() const
+uint256 CBlockHeader::GetHash() const 
 {
-    return Hash(BEGIN(nVersion), END(nNonce));
+
+// byte swap the 4 int/unsigned int values
+ #if WORDS_BIGENDIAN == 1
+        CBlockHeader BE; 
+        uint32_t src_tmp;
+        src_tmp= bswap_32(nVersion);
+        BE.nVersion = src_tmp;
+        src_tmp = bswap_32(nTime);
+        BE.nTime = src_tmp;
+        src_tmp = bswap_32(nBits);
+        BE.nBits = src_tmp;
+        src_tmp = bswap_32(nNonce);
+        BE.nNonce = src_tmp;
+        BE.hashPrevBlock=hashPrevBlock;
+        BE.hashPrevBlock.ByteSwap();
+        BE.hashMerkleRoot=hashMerkleRoot;
+        BE.hashMerkleRoot.ByteSwap();
+	return Hash(BEGIN(BE.nVersion), END(BE.nNonce)).ByteSwap(); 
+#endif
+
+
+	return Hash(BEGIN(nVersion), END(nNonce));
 }
 
 uint256 CBlock::BuildMerkleTree(bool* fMutated) const
diff --git a/src/protocol/handshake.cpp b/src/protocol/handshake.cpp
index 201f540..ec6524a 100644
--- a/src/protocol/handshake.cpp
+++ b/src/protocol/handshake.cpp
@@ -388,6 +388,7 @@ bool PushMultiChainVerack(CNode* pfrom, bool fIsVerackack)
     vector<unsigned char>vSigScript;
     uint64_t nNonce;
     
+ LogPrintf("+++ mchn: start PushMultiChainVerack %s\n", pfrom->addr.ToString());
     if(!fIsVerackack)
     {
         if(mc_gState->m_NetworkParams->m_Status != MC_PRM_STATUS_VALID)         // Ignoring version message from seed node in initial handshake
diff --git a/src/protocol/multichainscript.cpp b/src/protocol/multichainscript.cpp
index 41de1dd..e5c730b 100644
--- a/src/protocol/multichainscript.cpp
+++ b/src/protocol/multichainscript.cpp
@@ -1075,10 +1075,10 @@ int mc_Script::SetPermission(uint32_t type,uint32_t from,uint32_t to,uint32_t ti
     ptr[MC_DCT_SCRIPT_IDENTIFIER_LEN]=MC_DCT_SCRIPT_MULTICHAIN_PERMISSIONS_PREFIX;
     
     ptr+=MC_DCT_SCRIPT_IDENTIFIER_LEN+1;
-    mc_PutLE(ptr+ 0,&type,4);
-    mc_PutLE(ptr+ 4,&from,4);
-    mc_PutLE(ptr+ 8,&to,4);
-    mc_PutLE(ptr+12,&timestamp,4);
+    mc_PutLE(ptr+ 0,type,4);
+    mc_PutLE(ptr+ 4,from,4);
+    mc_PutLE(ptr+ 8,to,4);
+    mc_PutLE(ptr+12,timestamp,4);
     
     return SetData(buf,MC_DCT_SCRIPT_IDENTIFIER_LEN+1+16);
 }
@@ -1177,7 +1177,7 @@ int mc_Script::SetBlockSignature(const unsigned char* sig,int sig_size,uint32_t
         return err;
     }
     
-    mc_PutLE(buf,&sig_size,1);
+    mc_PutLE(buf,sig_size,1);
     err=SetData(buf,1);
     if(err)
     {
@@ -1190,14 +1190,14 @@ int mc_Script::SetBlockSignature(const unsigned char* sig,int sig_size,uint32_t
         return err;
     }
     
-    mc_PutLE(buf,&hash_type,1);
+    mc_PutLE(buf,hash_type,1);
     err=SetData(buf,1);
     if(err)
     {
         return err;
     }
     
-    mc_PutLE(buf,&key_size,1);
+    mc_PutLE(buf,key_size,1);
     err=SetData(buf,1);
     if(err)
     {
@@ -1272,7 +1272,7 @@ int mc_Script::SetAssetGenesis(int64_t quantity)
     ptr[MC_DCT_SCRIPT_IDENTIFIER_LEN]=MC_DCT_SCRIPT_MULTICHAIN_ASSET_GENESIS_PREFIX;
     
     ptr+=MC_DCT_SCRIPT_IDENTIFIER_LEN+1;
-    mc_PutLE(ptr+ 0,&quantity,8);
+    mc_PutLE(ptr+ 0,quantity,8);
     
     return SetData(buf,MC_DCT_SCRIPT_IDENTIFIER_LEN+1+8);    
 }
@@ -1375,7 +1375,7 @@ int mc_Script::SetAssetDetails(const char*name,int multiple,const unsigned char*
         return err;
     }
     
-    mc_PutLE(buf,&multiple,4);
+    mc_PutLE(buf,multiple,4);
     err=SetData(buf,4);
     if(err)
     {
@@ -1532,8 +1532,8 @@ int mc_Script::SetApproval(uint32_t approval,uint32_t timestamp)
     ptr[MC_DCT_SCRIPT_IDENTIFIER_LEN]=MC_DCT_SCRIPT_MULTICHAIN_APPROVE_PREFIX;
     
     ptr+=MC_DCT_SCRIPT_IDENTIFIER_LEN+1;
-    mc_PutLE(ptr+0,&approval,1);
-    mc_PutLE(ptr+1,&timestamp,4);
+    mc_PutLE(ptr+0,approval,1);
+    mc_PutLE(ptr+1,timestamp,4);
     
     return SetData(buf,MC_DCT_SCRIPT_IDENTIFIER_LEN+1+5);    
 }
@@ -2184,7 +2184,7 @@ int mc_Script::SetCachedScript(int offset, int *next_offset, int vin, unsigned c
         return MC_ERR_NOERROR;            
     }
 
-    mc_PutLE(buf,&vin,4);
+    mc_PutLE(buf,vin,4);
     err=SetData(buf,4);
     if(err)
     {
@@ -2742,4 +2742,4 @@ int mc_Script::DeleteDuplicatesInRange(int from,int to)
     m_CurrentElement=-1;
     
    return MC_ERR_NOERROR;
- }
\ No newline at end of file
+ }
diff --git a/src/protocol/multichaintx.cpp b/src/protocol/multichaintx.cpp
index 2e9f194..242810f 100644
--- a/src/protocol/multichaintx.cpp
+++ b/src/protocol/multichaintx.cpp
@@ -2241,7 +2241,7 @@ bool MultiChainTransaction_ProcessAssetIssuance(const CTransaction& tx,
                 if(stored_issuers.count(issuers[i]) == 0)
                 {
                     memcpy(issuer_buf,issuers[i].begin(),sizeof(uint160));
-                    mc_PutLE(issuer_buf+sizeof(uint160),&issuer_flags[i],4);
+                    mc_PutLE(issuer_buf+sizeof(uint160),issuer_flags[i],4);
                     if((int)i < mc_gState->m_Assets->MaxStoredIssuers())            // Adding list of issuers to the asset script
                     {
                         mc_gState->m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_ISSUER,issuer_buf,sizeof(issuer_buf));            
@@ -2454,7 +2454,7 @@ bool MultiChainTransaction_ProcessEntityCreation(const CTransaction& tx,
             if(stored_openers.count(openers[i]) == 0)
             {
                 memcpy(opener_buf,openers[i].begin(),sizeof(uint160));
-                mc_PutLE(opener_buf+sizeof(uint160),&opener_flags[i],4);
+                mc_PutLE(opener_buf+sizeof(uint160),opener_flags[i],4);
                 if((int)i < mc_gState->m_Assets->MaxStoredIssuers())
                 {
                     mc_gState->m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_ISSUER,opener_buf,sizeof(opener_buf));            
diff --git a/src/protocol/relay.cpp b/src/protocol/relay.cpp
index 8b498f8..4f6661a 100644
--- a/src/protocol/relay.cpp
+++ b/src/protocol/relay.cpp
@@ -643,7 +643,7 @@ int MultichainCollectChunks(mc_ChunkCollector* collector)
             ptrOut=&(payload[0]);
             *ptrOut=MC_RDT_EXPIRATION;
             ptrOut++;
-            mc_PutLE(ptrOut,&dest_expiration,sizeof(dest_expiration));
+            mc_PutLE(ptrOut,dest_expiration,sizeof(dest_expiration));
             ptrOut+=sizeof(dest_expiration);
             if(vRPPayload.size())
             {
diff --git a/src/rpc/rpcassets.cpp b/src/rpc/rpcassets.cpp
index 53294ed..f6af6ac 100644
--- a/src/rpc/rpcassets.cpp
+++ b/src/rpc/rpcassets.cpp
@@ -218,6 +218,9 @@ Value issuefromcmd(const Array& params, bool fHelp)
     {
         lpDetails->SetSpecialParamValue(MC_ENT_SPRM_NAME,(const unsigned char*)(asset_name.c_str()),asset_name.size());//+1);
     }        
+ #if WORDS_BIGENDIAN == 1
+	multiple = bswap_32(multiple);  // convert to LE format
+ #endif
     lpDetails->SetSpecialParamValue(MC_ENT_SPRM_ASSET_MULTIPLE,(unsigned char*)&multiple,4);
     
     if(is_open)
@@ -823,17 +826,17 @@ Value getmultibalances(const Array& params, bool fHelp)
             if(quantity > 0)
             {
                 quantity+=mc_GetLE(addresstxid_amounts->GetRow(0)+80,MC_AST_ASSET_QUANTITY_SIZE);
-                mc_PutLE(addresstxid_amounts->GetRow(0)+80,&quantity,MC_AST_ASSET_QUANTITY_SIZE);
+                mc_PutLE(addresstxid_amounts->GetRow(0)+80,quantity,MC_AST_ASSET_QUANTITY_SIZE);
                 row=addresstxid_amounts->Seek(buf);
                 quantity=txout.nValue;
                 if(row >= 0)
                 {
                     quantity+=mc_GetLE(addresstxid_amounts->GetRow(row)+80,MC_AST_ASSET_QUANTITY_SIZE);
-                    mc_PutLE(addresstxid_amounts->GetRow(row)+80,&quantity,MC_AST_ASSET_QUANTITY_SIZE);
+                    mc_PutLE(addresstxid_amounts->GetRow(row)+80,quantity,MC_AST_ASSET_QUANTITY_SIZE);
                 }
                 else
                 {                             
-                    mc_PutLE(buf+80,&quantity,MC_AST_ASSET_QUANTITY_SIZE);
+                    mc_PutLE(buf+80,quantity,MC_AST_ASSET_QUANTITY_SIZE);
                     addresstxid_amounts->Add(buf,buf+80);                        
                 }                
             }
@@ -880,11 +883,11 @@ Value getmultibalances(const Array& params, bool fHelp)
                         if(row >= 0)
                         {
                             quantity+=mc_GetLE(addresstxid_amounts->GetRow(row)+80,MC_AST_ASSET_QUANTITY_SIZE);
-                            mc_PutLE(addresstxid_amounts->GetRow(row)+80,&quantity,MC_AST_ASSET_QUANTITY_SIZE);
+                            mc_PutLE(addresstxid_amounts->GetRow(row)+80,quantity,MC_AST_ASSET_QUANTITY_SIZE);
                         }
                         else
                         {                             
-                            mc_PutLE(totbuf+80,&quantity,MC_AST_ASSET_QUANTITY_SIZE);
+                            mc_PutLE(totbuf+80,quantity,MC_AST_ASSET_QUANTITY_SIZE);
                             addresstxid_amounts->Add(totbuf,totbuf+80);                        
                         }                
                         
@@ -894,11 +897,11 @@ Value getmultibalances(const Array& params, bool fHelp)
                         if(row >= 0)
                         {
                             quantity+=mc_GetLE(addresstxid_amounts->GetRow(row)+80,MC_AST_ASSET_QUANTITY_SIZE);
-                            mc_PutLE(addresstxid_amounts->GetRow(row)+80,&quantity,MC_AST_ASSET_QUANTITY_SIZE);
+                            mc_PutLE(addresstxid_amounts->GetRow(row)+80,quantity,MC_AST_ASSET_QUANTITY_SIZE);
                         }
                         else
                         {                             
-                            mc_PutLE(buf+80,&quantity,MC_AST_ASSET_QUANTITY_SIZE);
+                            mc_PutLE(buf+80,quantity,MC_AST_ASSET_QUANTITY_SIZE);
                             addresstxid_amounts->Add(buf,buf+80);                        
                         }                
                     }
@@ -1195,7 +1198,7 @@ Value getaddressbalances(const Array& params, bool fHelp)
                         {
                             int64_t last=mc_GetLE(genesis_amounts->GetRow(row)+32,MC_AST_ASSET_QUANTITY_SIZE);
                             quantity+=last;
-                            mc_PutLE(genesis_amounts->GetRow(row)+32,&quantity,MC_AST_ASSET_QUANTITY_SIZE);
+                            mc_PutLE(genesis_amounts->GetRow(row)+32,quantity,MC_AST_ASSET_QUANTITY_SIZE);
                         }
                         else
                         {
@@ -1289,11 +1292,11 @@ Value getassetbalances(const Array& params, bool fHelp)
             {
                 const CBitcoinAddress& address = item.first;
                 const string& strName = item.second.name;
-                    if (strName == params[0].get_str())
-                    {
-                       setAddress.insert(address);                    
-                    }
+                if (strName == params[0].get_str())
+                {
+                   setAddress.insert(address);                    
                 }
+            }            
             check_account=true;
         }
     }
@@ -1411,7 +1414,7 @@ Value getassetbalances(const Array& params, bool fHelp)
                         {
                             int64_t last=mc_GetLE(genesis_amounts->GetRow(row)+32,MC_AST_ASSET_QUANTITY_SIZE);
                             quantity+=last;
-                            mc_PutLE(genesis_amounts->GetRow(row)+32,&quantity,MC_AST_ASSET_QUANTITY_SIZE);
+                            mc_PutLE(genesis_amounts->GetRow(row)+32,quantity,MC_AST_ASSET_QUANTITY_SIZE);
                         }
                         else
                         {
diff --git a/src/rpc/rpcdebug.cpp b/src/rpc/rpcdebug.cpp
index 99a9db6..d8a94b2 100644
--- a/src/rpc/rpcdebug.cpp
+++ b/src/rpc/rpcdebug.cpp
@@ -147,7 +147,7 @@ int64_t mcd_AddRows(mc_Database *m_DB,int key_size,int value_size,int row_count,
         memset(kbuf,0,key_size);
         memset(vbuf,0,value_size);
         total_rows+=per_commit_count;
-        mc_PutLE(vbuf,&total_rows,8);
+        mc_PutLE(vbuf,total_rows,8);
         err=m_DB->Write(kbuf,key_size,vbuf,value_size,MC_OPT_DB_DATABASE_TRANSACTIONAL);
         if(err)
         {
diff --git a/src/rpc/rpcutils.cpp b/src/rpc/rpcutils.cpp
index 235765f..1da5721 100644
--- a/src/rpc/rpcutils.cpp
+++ b/src/rpc/rpcutils.cpp
@@ -81,8 +81,8 @@ bool AssetRefDecode(unsigned char *bin, const char* string, const size_t stringL
     if ( (txIDPrefixInteger<0) || (txIDPrefixInteger>0xFFFF) )
         return false;
     
-    mc_PutLE(bin+0,&blockNum,4);
-    mc_PutLE(bin+4,&txOffset,4);
+    mc_PutLE(bin+0,blockNum,4);
+    mc_PutLE(bin+4,txOffset,4);
     bin[8]=(unsigned char)(txIDPrefixInteger%256);
     bin[9]=(unsigned char)(txIDPrefixInteger/256);
     
diff --git a/src/structs/hash.h b/src/structs/hash.h
index bcc1466..f2bf5e5 100644
--- a/src/structs/hash.h
+++ b/src/structs/hash.h
@@ -12,6 +12,7 @@
 #include "utils/serialize.h"
 #include "structs/uint256.h"
 #include "version/bcversion.h"
+#include <compat/byteswap.h>
 
 #include <vector>
 
@@ -157,7 +158,7 @@ uint256 SerializeHash(const T& obj, int nType=SER_GETHASH, int nVersion=PROTOCOL
 {
     CHashWriter ss(nType, nVersion);
     ss << obj;
-    return ss.GetHash();
+    return ss.GetHash().ByteSwap();
 }
 
 unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char>& vDataToHash);
diff --git a/src/structs/uint256.cpp b/src/structs/uint256.cpp
index a6a0a35..2487652 100644
--- a/src/structs/uint256.cpp
+++ b/src/structs/uint256.cpp
@@ -7,6 +7,8 @@
 #include "structs/uint256.h"
 
 #include "utils/utilstrencodings.h"
+#include "multichain/multichain.h"
+#include <compat/byteswap.h>
 
 #include <stdio.h>
 #include <string.h>
@@ -15,6 +17,14 @@ template <unsigned int BITS>
 base_uint<BITS>::base_uint(const std::string& str)
 {
     SetHex(str);
+
+#if WORDS_BIGENDIAN == 1
+    int i;
+    for ( i = 0; i < WIDTH; i++) {
+        pn[i] = bswap_32(pn[i]);
+    } 
+#endif
+
 }
 
 template <unsigned int BITS>
@@ -154,9 +164,20 @@ double base_uint<BITS>::getdouble() const
 template <unsigned int BITS>
 std::string base_uint<BITS>::GetHex() const
 {
+#if WORDS_BIGENDIAN == 1
+    uint32_t tmp[WIDTH]; 
+    for (int i = 0; i < WIDTH; i++)
+         tmp[i] = bswap_32(pn[i]) ;
+#endif
+
     char psz[sizeof(pn) * 2 + 1];
-    for (unsigned int i = 0; i < sizeof(pn); i++)
+    for (unsigned int i = 0; i < sizeof(pn); i++) {
+#if WORDS_BIGENDIAN == 1
+        sprintf(psz + i * 2, "%02x", ((unsigned char*)tmp)[sizeof(pn) - i - 1]);
+#else
         sprintf(psz + i * 2, "%02x", ((unsigned char*)pn)[sizeof(pn) - i - 1]);
+#endif
+    }
     return std::string(psz, psz + sizeof(pn) * 2);
 }
 
@@ -215,6 +236,19 @@ unsigned int base_uint<BITS>::bits() const
     }
     return 0;
 }
+template <unsigned int BITS>
+base_uint<BITS>&  base_uint<BITS>::ByteSwap()
+{
+#if WORDS_BIGENDIAN == 1
+    int i;
+    for ( i = 0; i < WIDTH; i++) {
+        uint32_t src_tmp;
+        src_tmp = bswap_32(pn[i]);
+        pn[i] = src_tmp;
+    }
+#endif
+    return *this;
+}
 
 // Explicit instantiations for base_uint<96>
 template int base_uint<96>::CompareTo(const base_uint<96>&) const;
@@ -232,6 +266,7 @@ template base_uint<160>& base_uint<160>::operator>>=(unsigned int);
 template base_uint<160>& base_uint<160>::operator*=(uint32_t b32);
 template base_uint<160>& base_uint<160>::operator*=(const base_uint<160>& b);
 template base_uint<160>& base_uint<160>::operator/=(const base_uint<160>& b);
+template base_uint<160>& base_uint<160>::ByteSwap(); 
 template int base_uint<160>::CompareTo(const base_uint<160>&) const;
 template bool base_uint<160>::EqualTo(uint64_t) const;
 template double base_uint<160>::getdouble() const;
@@ -249,6 +284,7 @@ template base_uint<256>& base_uint<256>::operator>>=(unsigned int);
 template base_uint<256>& base_uint<256>::operator*=(uint32_t b32);
 template base_uint<256>& base_uint<256>::operator*=(const base_uint<256>& b);
 template base_uint<256>& base_uint<256>::operator/=(const base_uint<256>& b);
+template base_uint<256>& base_uint<256>::ByteSwap(); 
 template int base_uint<256>::CompareTo(const base_uint<256>&) const;
 template bool base_uint<256>::EqualTo(uint64_t) const;
 template double base_uint<256>::getdouble() const;
@@ -347,6 +383,7 @@ static void inline HashFinal(uint32_t& a, uint32_t& b, uint32_t& c)
 
 uint64_t uint256::GetHash(const uint256& salt) const
 {
+
     uint32_t a, b, c;
     a = b = c = 0xdeadbeef + (WIDTH << 2);
 
diff --git a/src/structs/uint256.h b/src/structs/uint256.h
index 5616919..5bf9d9b 100644
--- a/src/structs/uint256.h
+++ b/src/structs/uint256.h
@@ -284,6 +284,7 @@ public:
     {
         s.read((char*)pn, sizeof(pn));
     }
+    base_uint& ByteSwap();
 };
 
 /** 96-bit unsigned big integer. */
@@ -312,7 +313,7 @@ public:
     uint256(uint64_t b) : base_uint<256>(b) {}
     explicit uint256(const std::string& str) : base_uint<256>(str) {}
     explicit uint256(const std::vector<unsigned char>& vch) : base_uint<256>(vch) {}
-    
+
     /**
      * The "compact" format is a representation of a whole
      * number N using an unsigned 32bit number similar to a
diff --git a/src/utils/declare.h b/src/utils/declare.h
index c636207..4019e45 100644
--- a/src/utils/declare.h
+++ b/src/utils/declare.h
@@ -207,7 +207,7 @@ struct mc_TerminalInput
 int mc_AllocSize(int items,int chunk_size,int item_size);
 void *mc_New(int Size);
 void mc_Delete(void *ptr);
-void mc_PutLE(void *dest,void *src,int dest_size);
+void mc_PutLE(void *dest,long src,int dest_size);
 int64_t mc_GetLE(void *src,int size);
 uint32_t mc_SwapBytes32(uint32_t src);
 int mc_BackupFile(const char *network_name,const char *filename, const char *extension,int options);
diff --git a/src/utils/serialize.h b/src/utils/serialize.h
index 133c983..cf03b8a 100644
--- a/src/utils/serialize.h
+++ b/src/utils/serialize.h
@@ -119,6 +119,7 @@ enum
 #define WRITEDATA(s, obj)   s.write((char*)&(obj), sizeof(obj))
 #define READDATA(s, obj)    s.read((char*)&(obj), sizeof(obj))
 
+
 inline unsigned int GetSerializeSize(char a,               int, int=0) { return sizeof(a); }
 inline unsigned int GetSerializeSize(signed char a,        int, int=0) { return sizeof(a); }
 inline unsigned int GetSerializeSize(unsigned char a,      int, int=0) { return sizeof(a); }
@@ -136,30 +137,30 @@ inline unsigned int GetSerializeSize(double a,             int, int=0) { return
 template<typename Stream> inline void Serialize(Stream& s, char a,               int, int=0) { WRITEDATA(s, a); }
 template<typename Stream> inline void Serialize(Stream& s, signed char a,        int, int=0) { WRITEDATA(s, a); }
 template<typename Stream> inline void Serialize(Stream& s, unsigned char a,      int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, signed short a,       int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, unsigned short a,     int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, signed int a,         int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, unsigned int a,       int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, signed long a,        int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, unsigned long a,      int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, signed long long a,   int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, unsigned long long a, int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, float a,              int, int=0) { WRITEDATA(s, a); }
-template<typename Stream> inline void Serialize(Stream& s, double a,             int, int=0) { WRITEDATA(s, a); }
+template<typename Stream> inline void Serialize(Stream& s, signed short a,       int, int=0) { a = htole16(a); WRITEDATA(s, a); }
+template<typename Stream> inline void Serialize(Stream& s, unsigned short a,     int, int=0) { a = htole16(a); WRITEDATA(s, a); }
+template<typename Stream> inline void Serialize(Stream& s, signed int a,         int, int=0) { a = htole32(a); WRITEDATA(s, a); }
+template<typename Stream> inline void Serialize(Stream& s, unsigned int a,       int, int=0) { a = htole32(a); WRITEDATA(s, a); }
+template<typename Stream> inline void Serialize(Stream& s, signed long a,        int, int=0) { a = htole64(a); WRITEDATA(s, a); }
+template<typename Stream> inline void Serialize(Stream& s, unsigned long a,      int, int=0) { a = htole64(a); WRITEDATA(s, a); }
+template<typename Stream> inline void Serialize(Stream& s, signed long long a,   int, int=0) { a = htole64(a); WRITEDATA(s, a); }
+template<typename Stream> inline void Serialize(Stream& s, unsigned long long a, int, int=0) { a = htole64(a); WRITEDATA(s, a); }
+template<typename Stream> inline void Serialize(Stream& s, float a,              int, int=0) { a = htole32(a); WRITEDATA(s, a); }
+template<typename Stream> inline void Serialize(Stream& s, double a,             int, int=0) { a = htole64(a); WRITEDATA(s, a); }
 
 template<typename Stream> inline void Unserialize(Stream& s, char& a,               int, int=0) { READDATA(s, a); }
 template<typename Stream> inline void Unserialize(Stream& s, signed char& a,        int, int=0) { READDATA(s, a); }
 template<typename Stream> inline void Unserialize(Stream& s, unsigned char& a,      int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, signed short& a,       int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, unsigned short& a,     int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, signed int& a,         int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, unsigned int& a,       int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, signed long& a,        int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, unsigned long& a,      int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, signed long long& a,   int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, unsigned long long& a, int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, float& a,              int, int=0) { READDATA(s, a); }
-template<typename Stream> inline void Unserialize(Stream& s, double& a,             int, int=0) { READDATA(s, a); }
+template<typename Stream> inline void Unserialize(Stream& s, signed short& a,       int, int=0) { READDATA(s, a); a=le16toh(a); }
+template<typename Stream> inline void Unserialize(Stream& s, unsigned short& a,     int, int=0) { READDATA(s, a); a=le16toh(a); }
+template<typename Stream> inline void Unserialize(Stream& s, signed int& a,         int, int=0) { READDATA(s, a); a=le32toh(a); }
+template<typename Stream> inline void Unserialize(Stream& s, unsigned int& a,       int, int=0) { READDATA(s, a); a=le32toh(a); }
+template<typename Stream> inline void Unserialize(Stream& s, signed long& a,        int, int=0) { READDATA(s, a); a=le64toh(a); }
+template<typename Stream> inline void Unserialize(Stream& s, unsigned long& a,      int, int=0) { READDATA(s, a); a=le64toh(a); }
+template<typename Stream> inline void Unserialize(Stream& s, signed long long& a,   int, int=0) { READDATA(s, a); a=le64toh(a); }
+template<typename Stream> inline void Unserialize(Stream& s, unsigned long long& a, int, int=0) { READDATA(s, a); a=le64toh(a); }
+template<typename Stream> inline void Unserialize(Stream& s, float& a,              int, int=0) { READDATA(s, a); a=le32toh(a); }
+template<typename Stream> inline void Unserialize(Stream& s, double& a,             int, int=0) { READDATA(s, a); a=le64toh(a); }
 
 inline unsigned int GetSerializeSize(bool a, int, int=0)                          { return sizeof(char); }
 template<typename Stream> inline void Serialize(Stream& s, bool a, int, int=0)    { char f=a; WRITEDATA(s, f); }
diff --git a/src/utils/tools.cpp b/src/utils/tools.cpp
index 33d50d2..2b7d72a 100644
--- a/src/utils/tools.cpp
+++ b/src/utils/tools.cpp
@@ -111,4 +111,4 @@ const char* mc_MapStringString::Get(const char* key)
 int mc_MapStringString::GetCount()
 {
     return ((std::map<string, string>*)mapObject)->size();
-}
\ No newline at end of file
+}
diff --git a/src/utils/utility.cpp b/src/utils/utility.cpp
index 809bf16..ad3560a 100644
--- a/src/utils/utility.cpp
+++ b/src/utils/utility.cpp
@@ -6,6 +6,7 @@
 #include <termios.h>
 #include <sys/ioctl.h>
 #include <ctype.h>
+#include <compat/byteswap.h>
 #endif
 
 #define MC_DCT_BUF_ALLOC_ITEMS          256
@@ -62,9 +63,13 @@ void mc_Delete(void *ptr)
     delete [] (int64_t*)ptr;
 }
 
-void mc_PutLE(void *dest,void *src,int dest_size)
+void mc_PutLE(void *dest,long src,int dest_size)
 {
-    memcpy(dest,src,dest_size);                                                 // Assuming all systems are little endian
+   #if WORDS_BIGENDIAN == 1
+	uint64_t src_tmp = src;
+	src = bswap_64(src_tmp);
+   #endif
+	memcpy(dest, &src,dest_size);
 }
 
 int64_t mc_GetLE(void *src,int size)
@@ -858,7 +863,7 @@ int mc_PutVarInt(unsigned char *buf,int max_size,int64_t value)
         return -1;
     }
     
-    mc_PutLE(buf+shift,&value,varint_size);    
+    mc_PutLE(buf+shift,value,varint_size);
     return shift+varint_size;
 }
 
diff --git a/src/utils/utilparse.cpp b/src/utils/utilparse.cpp
index 79e61d3..0fe727f 100644
--- a/src/utils/utilparse.cpp
+++ b/src/utils/utilparse.cpp
@@ -633,7 +633,7 @@ bool ParseMultichainTxOutToBuffer(uint256 hash,
                     memset(buf,0,MC_AST_ASSET_FULLREF_BUF_SIZE);
                     type=MC_PTP_ISSUE | MC_PTP_SEND;
                     quantity=1;
-                    mc_PutLE(buf+4,&type,4);
+                    mc_PutLE(buf+4,type,4);
                     mc_SetABRefType(buf,MC_AST_ASSET_REF_TYPE_SPECIAL);
                     mc_SetABQuantity(buf,quantity);
                     if(amounts->Seek(buf) < 0)
@@ -648,7 +648,7 @@ bool ParseMultichainTxOutToBuffer(uint256 hash,
                     memset(buf,0,MC_AST_ASSET_FULLREF_BUF_SIZE);
                     type=MC_PTP_CREATE | MC_PTP_SEND;
                     quantity=1;
-                    mc_PutLE(buf+4,&type,4);
+                    mc_PutLE(buf+4,type,4);
                     mc_SetABRefType(buf,MC_AST_ASSET_REF_TYPE_SPECIAL);
                     mc_SetABQuantity(buf,quantity);
                     if(amounts->Seek(buf) < 0)
@@ -663,7 +663,7 @@ bool ParseMultichainTxOutToBuffer(uint256 hash,
                     memset(buf,0,MC_AST_ASSET_FULLREF_BUF_SIZE);
                     type=MC_PTP_ADMIN | MC_PTP_SEND;
                     quantity=1;
-                    mc_PutLE(buf+4,&type,4);
+                    mc_PutLE(buf+4,type,4);
                     mc_SetABRefType(buf,MC_AST_ASSET_REF_TYPE_SPECIAL);
                     mc_SetABQuantity(buf,quantity);
                     if(amounts->Seek(buf) < 0)
@@ -678,7 +678,7 @@ bool ParseMultichainTxOutToBuffer(uint256 hash,
                     memset(buf,0,MC_AST_ASSET_FULLREF_BUF_SIZE);
                     type=MC_PTP_ACTIVATE | MC_PTP_SEND;
                     quantity=1;
-                    mc_PutLE(buf+4,&type,4);
+                    mc_PutLE(buf+4,type,4);
                     mc_SetABRefType(buf,MC_AST_ASSET_REF_TYPE_SPECIAL);
                     mc_SetABQuantity(buf,quantity);
                     if(amounts->Seek(buf) < 0)
@@ -704,7 +704,7 @@ bool ParseMultichainTxOutToBuffer(uint256 hash,
 */
             memset(buf,0,MC_AST_ASSET_FULLREF_BUF_SIZE);
             type=MC_PTP_SEND;
-            mc_PutLE(buf+4,&type,4);
+            mc_PutLE(buf+4,type,4);
             mc_SetABRefType(buf,MC_AST_ASSET_REF_TYPE_SPECIAL);
             quantity=txout.nValue;
             row=amounts->Seek(buf);
@@ -740,7 +740,7 @@ bool ParseMultichainTxOutToBuffer(uint256 hash,
             }
             memset(buf,0,MC_AST_ASSET_FULLREF_BUF_SIZE);
             type=MC_PTP_SEND;
-            mc_PutLE(buf+4,&type,4);
+            mc_PutLE(buf+4,type,4);
             mc_SetABRefType(buf,MC_AST_ASSET_REF_TYPE_SPECIAL);
             quantity=txout.nValue;
             row=amounts->Seek(buf);
diff --git a/src/utils/utilwrapper.cpp b/src/utils/utilwrapper.cpp
index bb1836c..7176716 100644
--- a/src/utils/utilwrapper.cpp
+++ b/src/utils/utilwrapper.cpp
@@ -1023,7 +1023,11 @@ std::string MultichainServerAddress()
     if(mc_gState->m_IPv4Address)
     {
         ptr=(unsigned char *)(&(mc_gState->m_IPv4Address));
-        result+=strprintf("%u.%u.%u.%u",ptr[3],ptr[2],ptr[1],ptr[0]);
+#if WORDS_BIGENDIAN == 1
+        result+=strprintf("%u.%u.%u.%u",ptr[0],ptr[1],ptr[2],ptr[3]);
+#else
+         result+=strprintf("%u.%u.%u.%u",ptr[3],ptr[2],ptr[1],ptr[0]);
+#endif
     }
     else
     {
@@ -1183,4 +1187,4 @@ int mc_FindIPv4ServerAddress(uint32_t *all_ips,int max_ips)
      return c;
 }
 
-        
\ No newline at end of file
+        
diff --git a/src/v8/v8engine.cpp b/src/v8/v8engine.cpp
index 43e1cfd..edf6c25 100644
--- a/src/v8/v8engine.cpp
+++ b/src/v8/v8engine.cpp
@@ -8,8 +8,8 @@
 #include "v8/v8utils.h"
 #include <libplatform/libplatform.h>
 
-extern char _binary_icudtl_dat_start;
-extern char _binary_icudtl_dat_end;
+extern char _binary_icudtb_dat_start;
+extern char _binary_icudtb_dat_end;
 extern char _binary_natives_blob_bin_start;
 extern char _binary_natives_blob_bin_end;
 extern char _binary_snapshot_blob_bin_start;
@@ -78,17 +78,17 @@ void V8Engine::InitializeV8()
     fs::path v8TempDir = tempDir / "v8";
     fs::create_directories(v8TempDir);
 
-    fs::path icudtl_blob = v8TempDir / "icudtl.dat";
+    fs::path icudtb_blob = v8TempDir / "icudtb.dat";
     fs::path natives_blob = v8TempDir / "natives_blob.bin";
     fs::path snapshot_blob = v8TempDir / "snapshot_blob.bin";
 
-    WriteBinaryFile(icudtl_blob, &_binary_icudtl_dat_start, &_binary_icudtl_dat_end - &_binary_icudtl_dat_start);
+    WriteBinaryFile(icudtb_blob, &_binary_icudtb_dat_start, &_binary_icudtb_dat_end - &_binary_icudtb_dat_start);
     WriteBinaryFile(natives_blob, &_binary_natives_blob_bin_start,
                     &_binary_natives_blob_bin_end - &_binary_natives_blob_bin_start);
     WriteBinaryFile(snapshot_blob, &_binary_snapshot_blob_bin_start,
                     &_binary_snapshot_blob_bin_end - &_binary_snapshot_blob_bin_start);
 
-    v8::V8::InitializeICUDefaultLocation(icudtl_blob.string().c_str());
+    v8::V8::InitializeICUDefaultLocation(icudtb_blob.string().c_str());
     v8::V8::InitializeExternalStartupData(natives_blob.string().c_str());
 
     fs::remove_all(tempDir);
diff --git a/src/wallet/dbflat.cpp b/src/wallet/dbflat.cpp
index 2c41c2f..261f18b 100644
--- a/src/wallet/dbflat.cpp
+++ b/src/wallet/dbflat.cpp
@@ -8,7 +8,7 @@
 #include <boost/filesystem.hpp>
 #include <boost/thread.hpp>
 #include <boost/version.hpp>
-
+#include <compat/byteswap.h>
 
 using namespace std;
 using namespace boost;
@@ -52,7 +52,34 @@ void PrintDataStreamKey(const char *msg,const CDataStream& ss)
         printf("\n");
     }
 }
-
+uint32_t mc_read(int _fd, unsigned int * _buf, size_t _nbyte ) 
+{
+   uint32_t ret, tmp;
+   ret = read(_fd, &tmp, _nbyte);
+   unsigned char *ptr =(unsigned char*)&tmp;
+   unsigned char *ptrEnd = ptr+_nbyte;
+   int shift =  0; 
+   uint32_t result =0;
+   while(ptr<ptrEnd)
+    {
+        result|=((int32_t)(*ptr))<<shift;
+        shift+=8;
+        ptr++;
+    }
+   
+   *_buf = result;
+   
+   return ret;
+}
+uint32_t mc_write(int _fd, unsigned int _buf, size_t _nbyte )
+{  
+   uint32_t tmp = _buf;
+#if WORDS_BIGENDIAN == 1
+        tmp = bswap_32(_buf);
+#endif
+   uint32_t ret = write(_fd, &tmp, _nbyte); 
+   return ret;
+}
 void mc_DBFlatPos::Zero()
 {
     memset(this,0,sizeof(mc_DBFlatPos));
@@ -751,10 +778,10 @@ bool CDBFlat::Write(CDataStream& ssKey, CDataStream& ssValue, bool fOverwrite)
         }
     
         SetFileOffset(pos.m_Offset);
-        
+         
         write(m_FileHan,&pos.m_Flags,MC_DBF_FLAGS_FIELDSIZE);
-        write(m_FileHan,&pos.m_KeyLen,1);
-        write(m_FileHan,&pos.m_ValLen,1);
+        mc_write(m_FileHan,pos.m_KeyLen,1);
+        mc_write(m_FileHan,pos.m_ValLen,1);
         write(m_FileHan,&ssKey[0],pos.m_KeyLen);
         write(m_FileHan,&ssValue[0],pos.m_ValLen);
         if(GetFileSize() < pos.NextOffset())
@@ -790,8 +817,8 @@ bool CDBFlat::Write(CDataStream& ssKey, CDataStream& ssValue, bool fOverwrite)
     pos.m_Offset=m_FileSize;
     SetFileOffset(pos.m_Offset);
     write(m_FileHan,&pos.m_Flags,MC_DBF_FLAGS_FIELDSIZE);
-    write(m_FileHan,&pos.m_KeyLen,key_size_bytes);
-    write(m_FileHan,&pos.m_ValLen,val_size_bytes);
+    mc_write(m_FileHan,pos.m_KeyLen,key_size_bytes);
+    mc_write(m_FileHan,pos.m_ValLen, val_size_bytes);
     if(pos.m_KeyLen)write(m_FileHan,&ssKey[0],pos.m_KeyLen);
     if(pos.m_ValLen)write(m_FileHan,&ssValue[0],pos.m_ValLen);
     
@@ -969,11 +996,11 @@ int CDBFlat::ReadAtCursor(void* pcursor, CDataStream& ssKey, CDataStream& ssValu
             }            
             lpPos->m_KeyLen=0;
             lpPos->m_ValLen=0;
-            if(read(m_FileHan,&(lpPos->m_KeyLen),key_size_bytes) != key_size_bytes)
+            if(mc_read(m_FileHan,&(lpPos->m_KeyLen),key_size_bytes) != key_size_bytes)
             {
                 return MC_DBW_CODE_DB_NOSERVER;  
             }
-            if(read(m_FileHan,&(lpPos->m_ValLen),val_size_bytes) != val_size_bytes)
+            if(mc_read(m_FileHan,&(lpPos->m_ValLen),val_size_bytes) != val_size_bytes)
             {
                 return MC_DBW_CODE_DB_NOSERVER;  
             }            
@@ -1221,4 +1248,4 @@ bool CDBFlat::Rewrite(CDBFlatEnv *lpEnv,const string& strFile, const char* pszSk
     lpEnv->RemoveDb(strFileCopy);
     
     return true;
-}
\ No newline at end of file
+}
diff --git a/src/wallet/wallet.cpp b/src/wallet/wallet.cpp
index e389484..0245deb 100644
--- a/src/wallet/wallet.cpp
+++ b/src/wallet/wallet.cpp
@@ -2734,7 +2734,7 @@ int CWallet::SelectMultiChainCombineCoinsMinConf(int nConfMine, int nConfTheirs,
             out_i=output.i;
             
             memcpy(buf_map,&hash,32);
-            mc_PutLE(buf_map+32,&out_i,4);
+            mc_PutLE(buf_map+32,out_i,4);
             int row=in_map->Seek(buf_map);
             if(row >= 0)
             {
@@ -2883,7 +2883,7 @@ bool CWallet::SelectMultiChainCoinsMinConf(const CAmount& nTargetValue, int nCon
             out_i=output.i;
             
             memcpy(buf_map,&hash,32);
-            mc_PutLE(buf_map+32,&out_i,4);
+            mc_PutLE(buf_map+32,out_i,4);
             int row=in_map->Seek(buf_map);
             if(row >= 0)
             {
@@ -3058,7 +3058,7 @@ bool CWallet::SelectMultiChainCoins(const CAmount& nTargetValue, vector<COutput>
                 out_i=out.i;
 
                 memcpy(buf_map,&hash,32);                                       // Retrieving coin index in the matrix
-                mc_PutLE(buf_map+32,&out_i,4);
+                mc_PutLE(buf_map+32,out_i,4);
                 int row=in_map->Seek(buf_map);
                 
                 if(row >= 0)
diff --git a/src/wallet/walletcoins.cpp b/src/wallet/walletcoins.cpp
index 3ab55f7..0f74dc9 100644
--- a/src/wallet/walletcoins.cpp
+++ b/src/wallet/walletcoins.cpp
@@ -552,7 +552,7 @@ int64_t mc_GetABCoinQuantity(void *ptr,int coin_id)
 
 void mc_SetABCoinQuantity(void *ptr,int coin_id,int64_t quantity)
 {
-    mc_PutLE((unsigned char*)ptr+MC_AST_ASSET_QUANTITY_OFFSET+coin_id*MC_AST_ASSET_QUANTITY_SIZE,&quantity,MC_AST_ASSET_QUANTITY_SIZE);        
+    mc_PutLE((unsigned char*)ptr+MC_AST_ASSET_QUANTITY_OFFSET+coin_id*MC_AST_ASSET_QUANTITY_SIZE,quantity,MC_AST_ASSET_QUANTITY_SIZE);        
 }
 
 
@@ -719,8 +719,8 @@ bool InsertCoinIntoMatrix(int coin_id,
     
     
     memcpy(buf_map,&hash,32);                                                   // Updating txid/vout->coin id map
-    mc_PutLE(buf_map+32,&out_i,4);
-    mc_PutLE(buf_map+36,&coin_id,4);
+    mc_PutLE(buf_map+32,out_i,4);
+    mc_PutLE(buf_map+36,coin_id,4);
     in_map->Add(buf_map,buf_map+36);
 
     for(int i=0;i<tmp_amounts->GetCount();i++)                                  // Inserting asset amounts into the matrix
@@ -1206,7 +1206,7 @@ bool CalculateChangeAmounts(CWallet *lpWallet,
                             memset(buf,0,MC_AST_ASSET_FULLREF_BUF_SIZE+sizeof(int));
                             memcpy(buf,tmp_amounts->GetRow(i),MC_AST_ASSET_QUANTITY_OFFSET);
                             mc_SetABQuantity(buf,quantity);
-                            mc_PutLE(buf+MC_AST_ASSET_FULLREF_BUF_SIZE,&group_id,sizeof(int));
+                            mc_PutLE(buf+MC_AST_ASSET_FULLREF_BUF_SIZE,group_id,sizeof(int));
                             err=change_amounts->Add(buf);
                             if(err)
                             {
@@ -1373,7 +1373,7 @@ bool SelectCoinsToUse(const vector<COutPoint>* lpCoinsToUse,
         out_i=coin.n;
 
         memcpy(buf_map,&hash,32);
-        mc_PutLE(buf_map+32,&out_i,4);
+        mc_PutLE(buf_map+32,out_i,4);
         int row=in_map->Seek(buf_map);
         
         if(row<0)
@@ -1474,7 +1474,7 @@ bool SelectAssetCoins(CWallet *lpWallet,
             out_i=pcoin.second;
 
             memcpy(buf_map,&hash,32);
-            mc_PutLE(buf_map+32,&out_i,4);
+            mc_PutLE(buf_map+32,out_i,4);
             int row=in_map->Seek(buf_map);
             coin_id=mc_GetLE(in_map->GetRow(row)+36,4);
             quantity=1;
@@ -2321,7 +2321,7 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
     memset(in_row,-1,in_size);
     memset(in_row,0,MC_AST_ASSET_QUANTITY_OFFSET);
     type=0;
-    mc_PutLE(in_row+4,&type,4);
+    mc_PutLE(in_row+4,type,4);
     mc_SetABRefType(in_row,MC_AST_ASSET_REF_TYPE_SPECIAL);
     in_amounts->Add(in_row);
     
@@ -2329,7 +2329,7 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
     in_special_row[1]=in_amounts->GetCount();
     memset(in_row,0,in_size);
     type=0;
-    mc_PutLE(in_row+4,&type,4);
+    mc_PutLE(in_row+4,type,4);
     mc_SetABRefType(in_row,MC_AST_ASSET_REF_TYPE_SPECIAL);
     in_amounts->Add(in_row);
     
@@ -2337,7 +2337,7 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
     in_special_row[2]=in_amounts->GetCount();
     memset(in_row,0,in_size);
     type=0;
-    mc_PutLE(in_row+4,&type,4);
+    mc_PutLE(in_row+4,type,4);
     mc_SetABRefType(in_row,MC_AST_ASSET_REF_TYPE_SPECIAL);
     in_amounts->Add(in_row);
     
@@ -2345,7 +2345,7 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
     in_special_row[3]=in_amounts->GetCount();
     memset(in_row,0,in_size);
     type=MC_PTP_SEND;
-    mc_PutLE(in_row+4,&type,4);
+    mc_PutLE(in_row+4,type,4);
     mc_SetABRefType(in_row,MC_AST_ASSET_REF_TYPE_SPECIAL);
     in_amounts->Add(in_row);
     
@@ -2354,7 +2354,7 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
     memset(in_row,0,in_size);
     type=MC_PTP_SEND;
     mc_SetABRefType(in_row,MC_AST_ASSET_REF_TYPE_SPECIAL);
-    mc_PutLE(in_row+4,&type,4);
+    mc_PutLE(in_row+4,type,4);
     in_amounts->Add(in_row);
     
                                                                                 // Issue row, coin value if input has issue permission, 0 otherwise
@@ -2363,7 +2363,7 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
         in_special_row[5]=in_amounts->GetCount();
         memset(in_row,0,in_size);
         type=MC_PTP_ISSUE | MC_PTP_SEND;
-        mc_PutLE(in_row+4,&type,4);
+        mc_PutLE(in_row+4,type,4);
         mc_SetABRefType(in_row,MC_AST_ASSET_REF_TYPE_SPECIAL);
         in_amounts->Add(in_row);
     }
@@ -2374,7 +2374,7 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
         in_special_row[6]=in_amounts->GetCount();
         memset(in_row,0,in_size);
         type=MC_PTP_ADMIN | MC_PTP_SEND;
-        mc_PutLE(in_row+4,&type,4);
+        mc_PutLE(in_row+4,type,4);
         mc_SetABRefType(in_row,MC_AST_ASSET_REF_TYPE_SPECIAL);
         in_amounts->Add(in_row);
     }
@@ -2385,7 +2385,7 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
         in_special_row[7]=in_amounts->GetCount();
         memset(in_row,0,in_size);
         type=MC_PTP_ACTIVATE | MC_PTP_SEND;
-        mc_PutLE(in_row+4,&type,4);
+        mc_PutLE(in_row+4,type,4);
         mc_SetABRefType(in_row,MC_AST_ASSET_REF_TYPE_SPECIAL);
         in_amounts->Add(in_row);
     }
@@ -2396,7 +2396,7 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
         in_special_row[8]=in_amounts->GetCount();
         memset(in_row,0,in_size);
         type=MC_PTP_WRITE | MC_PTP_SEND;
-        mc_PutLE(in_row+4,&type,4);
+        mc_PutLE(in_row+4,type,4);
         mc_SetABRefType(in_row,MC_AST_ASSET_REF_TYPE_SPECIAL);
         in_amounts->Add(in_row);
     }
@@ -2407,7 +2407,7 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
         in_special_row[9]=in_amounts->GetCount();
         memset(in_row,0,in_size);
         type=MC_PTP_CREATE | MC_PTP_SEND;
-        mc_PutLE(in_row+4,&type,4);
+        mc_PutLE(in_row+4,type,4);
         mc_SetABRefType(in_row,MC_AST_ASSET_REF_TYPE_SPECIAL);
         in_amounts->Add(in_row);
     }
-- 
1.8.3.1

